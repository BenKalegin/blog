<head>
<title>gd 2.0.33</title>
</head>

<body>

<H3>Table of Contents</H3>
<UL>
<LI><A HREF="#basics">gd basics: using gd in your program</A>
<LI><A HREF="#webpng">webpng: a useful example</A>
<LI><A HREF="#reference">Function and type reference by category</A>
<LI><A HREF="#gdformat">About the additional .gd image file format</A>
<LI><A HREF="#informing"><strong>Please</strong>
 tell us you're using gd!</A>
<LI><A HREF="#support">How do I get support?</A>
<LI><A HREF="#index">Alphabetical quick index</A>
</UL>

<A NAME="basics"><H3>gd basics: using gd in your program</H3></A>
gd lets you create PNG or JPEG images on the fly. To use gd in your
program, include the file gd.h, and link with the gd
library and the other required libraries; the syntax for
most Unix flavors is:
<pre>
-lgd -lpng -lz -ljpeg -lfreetype -lm
</pre>
Assuming that all of these libraries are available.
<P>
If you want to use the provided simple fonts, include
gdfontt.h, gdfonts.h, gdfontmb.h, gdfontl.h and/or gdfontg.h. For
more impressive results, install FreeType 2.x and use the 
<a href="#gdImageStringFT">gdImageStringFT</a>
function. If you are not using the provided Makefile and/or a 
library-based approach, be sure to include the source modules as well in your
project. (They may be too large for 16-bit memory models,
that is, 16-bit DOS and Windows.)
<P>
Here is a short example program. <strong>(For a more advanced example,
see gddemo.c, included in the distribution. gddemo.c is NOT the same program;
it demonstrates additional features!)</strong>
<P>
<PRE>
/* Bring in gd library functions */
#include "gd.h"

/* Bring in standard I/O so we can output the PNG to a file */
#include &lt;stdio.h&gt;

int main() {
  /* Declare the image */
  <A HREF="#gdImagePtr">gdImagePtr</A> im;
  /* Declare output files */
  FILE *pngout, *jpegout;
  /* Declare color indexes */
  int black;
  int white;

  /* Allocate the image: 64 pixels across by 64 pixels tall */
  im = <A HREF="#gdImageCreate">gdImageCreate</A>(64, 64);

  /* Allocate the color black (red, green and blue all minimum).
    Since this is the first color in a new image, it will
    be the background color. */
  black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  

  /* Allocate the color white (red, green and blue all maximum). */
  white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
  
  /* Draw a line from the upper left to the lower right,
    using white color index. */
  <A HREF="#gdImageLine">gdImageLine</A>(im, 0, 0, 63, 63, white);  

  /* Open a file for writing. "wb" means "write binary", important
    under MSDOS, harmless under Unix. */
  pngout = fopen("test.png", "wb");

  /* Do the same for a JPEG-format file. */
  jpegout = fopen("test.jpg", "wb");

  /* Output the image to the disk file in PNG format. */
  <A HREF="#gdImagePng">gdImagePng</A>(im, pngout);

  /* Output the same image in JPEG format, using the default
    JPEG quality setting. */
  <A HREF="#gdImageJpeg">gdImageJpeg</A>(im, jpegout, -1);

  /* Close the files. */
  fclose(pngout);
  fclose(jpegout);

  /* Destroy the image in memory. */
  <A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
}
</PRE>
When executed, this program creates an image, allocates
two colors (the first color allocated becomes the background
color), draws a diagonal line (note that 0, 0 is the upper
left corner), writes the image to PNG and JPEG files, and
destroys the image.
<P>
The above example program should
give you an idea of how the package works.
gd provides many additional functions, which are listed
in the following reference chapters, complete with code
snippets demonstrating each. There is also an
<A HREF="#index">alphabetical index</A>.
<H3><A NAME="webpng">Webpng: a more powerful gd example</A></H3>
Webpng is a simple utility program to manipulate PNGs from the
command line. It is written for Unix and similar command-line
systems, but should be easily adapted for other environments.
Webpng allows you to set transparency and interlacing and
output interesting information about the PNG in question.
<P>
webpng.c is provided in the distribution. Unix users can
simply type "make webpng" to compile the program. Type
"webpng" with no arguments to see the available options.
<H2><A NAME="reference">Function and type reference</A></H2>
<UL>
<LI><A HREF="#types">Types</A></LI>
<LI><A HREF="#creating">Image creation, destruction, loading and saving</A></LI>
<LI><A HREF="#drawing">Drawing, styling, brushing, tiling and
filling functions</A></LI>
<LI><A HREF="#query">Query functions (not color-related)</A></LI>
<LI><A HREF="#fonts">Font and text-handling functions</A></LI>
<LI><A HREF="#colors">Color handling functions</A></LI>
<LI><A HREF="#copying">Copying, resizing, rotating, deformation and filter
functions</A></LI>
<LI><A HREF="#misc">Miscellaneous Functions</A></LI>
<LI><A HREF="#constants">Constants</A></LI>
</UL>
<H3><A NAME="types">Types</A></H3>
<DL>
<DT><A NAME="gdImage"><code>gdImage</code><strong>(TYPE)</strong></A>
<DD>
The data structure in which gd stores images. <A HREF="#gdImageCreate">
gdImageCreate</A>, <a href="#gdImageCreateTrueColor">gdImageCreateTrueColor</a>
and the various image file-loading functions return
a pointer to this type, and the other functions expect to receive
a pointer to this type as their first argument. It is reasonably safe to
examine any of the members of this structure. It is also reasonably
safe to modify individual pixels within the <code>pixels</code> 
or <code>tpixels</code> arrays. If the <code>trueColor</code> flag
is set, the <code>tpixels</code> array is valid; otherwise the
<code>pixels</code> array is valid.
<p>
The <code>colorsTotal</code>, <code>red</code>, <code>green</code>,
<code>blue</code>, <code>alpha</code> and <code>open</code> arrays
manage the palette. They are valid only when the <code>trueColor</code>
flag is not set. 
The <code>transparent</code> value contains the palette index of the first
transparent color as read-only information for backwards compatibility;
gd 2.0 stores this information in the <code>alpha</code> array so that
variable transparency can be supported for each palette entry. However,
for truecolor images, <code>transparent</code> represents a single
RGB color which is <strong>always 100% transparent</strong>, and this
feature is generally supported by browsers which do not support 
full alpha channels.
<PRE>
typedef struct {
  /* Palette-based image pixels */
  unsigned char ** pixels;
  int sx;
  int sy;
  /* These are valid in palette images only. See also
  /* 'alpha', which appears later in the structure to
    preserve binary backwards compatibility */
  int colorsTotal;
  int red[gdMaxColors];
  int green[gdMaxColors];
  int blue[gdMaxColors]; 
  int open[gdMaxColors];
  /* For backwards compatibility, this is set to the
    first palette entry with 100% transparency,
    and is also set and reset by the 
    gdImageColorTransparent function. Newer
    applications can allocate palette entries
    with any desired level of transparency; however,
    bear in mind that many viewers, notably
    many web browsers, fail to implement
    full alpha channel for PNG and provide
    support for full opacity or transparency only. */
  int transparent;
  int *polyInts;
  int polyAllocated;
  struct gdImageStruct *brush;
  struct gdImageStruct *tile;  
  int brushColorMap[gdMaxColors];
  int tileColorMap[gdMaxColors];
  int styleLength;
  int stylePos;
  int *style;
  int interlace;
  /* New in 2.0: alpha channel for palettes. Note that only
    Macintosh Internet Explorer and (possibly) Netscape 6
    really support multiple levels of transparency in
    palettes, to my knowledge, as of 2/15/01. Most
    common browsers will display 100% opaque and
    100% transparent correctly, and do something 
    unpredictable and/or undesirable for levels
    in between. TBB */
  int alpha[gdMaxColors]; 
  /* Truecolor flag and pixels. New 2.0 fields appear here at the
    end to minimize breakage of existing object code. */
  int trueColor;
  int ** tpixels;
  /* Should alpha channel be copied, or applied, each time a
    pixel is drawn? This applies to truecolor images only.
    No attempt is made to alpha-blend in palette images,
    even if semitransparent palette entries exist. 
    To do that, build your image as a truecolor image,
    then quantize down to 8 bits. */
  int alphaBlendingFlag;
  /* Should the alpha channel of the image be saved? This affects
    PNG at the moment; other future formats may also
    have that capability. JPEG doesn't. */
  int saveAlphaFlag;
} gdImage;
</PRE>
<p>
The order of the structure members may appear confusing, but was chosen
deliberately to increase backwards compatibility with existing gd 1.x-based
binary code that references particular structure members.
<DT><A NAME="gdImagePtr">gdImagePtr</A> <strong>(TYPE)</strong>
<DD>
A pointer to an image structure. <A HREF="#gdImageCreate">gdImageCreate</A>
returns this type, and the other functions expect it as the first
argument.
<DT><A NAME="gdIoCtx">gdIOCtx</a> <strong>(TYPE)</strong>
<DD>
Most of the gd functions that read and write files, such as
<a href="#gdImagePng">gdImagePng</a> and <a href="#gdImageCreateFromJpeg"></a>,
also have variants that accept a gdIOCtx structure; see
<a href="#gdImagePngCtx">gdImagePngCtx</a> and 
<a href="#gdImageCreateFromJpegCtx">gdImageCreateFromJpegCtx</a>. Those who wish to provide
their own custom routines to read and write images can populate a
gdIOCtx structure with functions of their own devising to 
to read and write data. For image reading, the only mandatory
functions are getC and getBuf, which must return the number of
characters actually read, or a negative value on error or EOF.
These functions must read the number of characters requested 
unless at the end of the file. For image writing, the only mandatory 
functions are putC and putBuf, which return the number of 
characters written; these functions must write the number of 
characters requested except in the event of an error. The seek
and tell functions are only required in conjunction with the
<code>gd2</code> file format, which supports quick loading of
partial images. The gd_free function will not be invoked when
calling the standard Ctx functions; it is an implementation
convenience when adding new data types to gd. For examples,
see gd_png.c, gd_gd2.c, gd_jpeg.c, etc., all of which rely
on gdIOCtx to implement the standard image read and write functions.

<pre>
typedef struct gdIOCtx
{
  int (*getC) (struct gdIOCtx *);
  int (*getBuf) (struct gdIOCtx *, void *, int wanted);

  void (*putC) (struct gdIOCtx *, int);
  int (*putBuf) (struct gdIOCtx *, const void *, int wanted);

  /* seek must return 1 on SUCCESS, 0 on FAILURE. Unlike fseek! */
  int (*seek) (struct gdIOCtx *, const int);

  long (*tell) (struct gdIOCtx *);

  void (*gd_free) (struct gdIOCtx *);

} gdIOCtx;
</pre>


<DT><A NAME="gdFont">gdFont</A> <strong>(TYPE)</strong>
<DD>
A font structure. Used to declare the characteristics of a font.
Please see the files gdfontl.c and gdfontl.h for an example of the
proper declaration of this structure. You can provide your
own font data by providing such a structure and the associated
pixel array. You can determine the width and height of a single
character in a font by examining the w and h members of the
structure. If you will not be creating your own fonts, you will
not need to concern yourself with the rest of the components of this
structure.
<PRE>
typedef struct {
  /* # of characters in font */
  int nchars;
  /* First character is numbered... (usually 32 = space) */
  int offset;
  /* Character width and height */
  int w;
  int h;
  /* Font data; array of characters, one row after another.
    Easily included in code, also easily loaded from
    data files. */
  char *data;
} gdFont;
</PRE>
<DT><A NAME="gdFontPtr">gdFontPtr</A> <strong>(TYPE)</strong>
<DD>
A pointer to a font structure. Text-output functions expect these
as their second argument, following the <A HREF="#gdImagePtr">
gdImagePtr</A> argument. Two such pointers are declared in the
provided include files gdfonts.h and gdfontl.h.
<DT><A NAME="gdPoint">gdPoint</A> <strong>(TYPE)</strong>
<DD>
Represents a point in the coordinate space of the image; used
by <A HREF="#gdImagePolygon">gdImagePolygon</A>,
<A HREF="#gdImageOpenPolygon">gdImageOpenPolygon</A> and
<A HREF="#gdImageFilledPolygon">gdImageFilledPolygon</A>.
<PRE>
typedef struct {
        int x, y;
} gdPoint, *gdPointPtr;
</PRE>
<DT><A NAME="gdPointPtr">gdPointPtr</A> <strong>(TYPE)</strong>
<DD>
A pointer to a <A HREF="#gdPoint">gdPoint</A> structure; passed
as an argument to <A HREF="#gdImagePolygon">gdImagePolygon</A>,
<A HREF="#gdImageOpenPolygon">gdImageOpenPolygon</A>
and <A HREF="#gdImageFilledPolygon">gdImageFilledPolygon</A>.
</DL>
<DT><A NAME="gdFTStringExtra">gdFTStringExtra</a> <strong>(TYPE)</strong>
<DD>
A structure used to pass additional parameters to the
<a href="#gdImageStringFTEx">gdImageStringFTEx</a> function. See
<a href="#gdImageStringFTEx">gdImageStringFTEx</a> for the
structure definition.
</DD>
<DT><A NAME="gdFTStringExtraPtr">gdFTStringExtraPtr</a> <strong>(TYPE)</strong>
<DD>
A pointer to a structure used to pass additional parameters to the
<a href="#gdImageStringFTEx">gdImageStringFTEx</a> function. See
<a href="#gdImageStringFTEx">gdImageStringFTEx</a> for the
structure definition.
</DD>
<DT><A NAME="gdSource">gdSource</A> <strong>(TYPE)</strong>
<DD>
<pre>
typedef struct {
        int (*source) (void *context, char *buffer, int len);
        void *context;
} gdSource, *gdSourcePtr;
</pre>
Represents a source from which a PNG can be read.
Programmers who do not wish to read PNGs from a file can provide
their own alternate input mechanism, using the
<a href="#gdImageCreateFromPngSource">gdImageCreateFromPngSource</a> function.
See the documentation of that function for an example of the
proper use of this type.
<DT><A NAME="gdSink">gdSink</A> <strong>(TYPE)</strong>
<DD>
<PRE>
typedef struct {
        int (*sink) (void *context, char *buffer, int len);
        void *context;
} gdSink, *gdSinkPtr;
</PRE>
Represents a "sink" (destination) to which a PNG can be written.
Programmers who do not wish to write PNGs to a file can provide
their own alternate output mechanism, using the
<a href="#gdImagePngToSink">gdImagePngToSink</a> function.
See the documentation of that function for an example of the
proper use of this type.
<H3><A NAME="creating">Image creation, destruction, loading and saving</A></H3>
<DL>
<DT><A NAME="gdImageCreate">gdImageCreate(sx, sy)</A>
<strong>(FUNCTION)</strong>
<DD>
gdImageCreate is called to create palette-based images, with no
more than 256 colors. Invoke gdImageCreate
with the x and y dimensions of the desired image. gdImageCreate
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or
NULL if unable to
allocate the image. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
im = gdImageCreate(64, 64);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCreateTrueColor">gdImageCreateTrueColor(sx, sy)</A>
<strong>(FUNCTION)</strong>
<DD>
gdImageCreateTrueColor is called to create truecolor images, with 
an essentially unlimited number of colors. Invoke gdImageCreateTrueColor
with the x and y dimensions of the desired image. gdImageCreateTrueColor
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or
NULL if unable to
allocate the image. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<p>
Truecolor images are always filled with black at creation time.
There is no concept of a "background" color index.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
im = gdImageCreateTrueColor(64, 64);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCreateFromJpeg">gdImageCreateFromJpeg(FILE *in)</A>
<strong>(FUNCTION)</strong>
<br>
<A NAME="gdImageCreateFromJpegPtr">gdImageCreateFromJpegPtr(int size, void *data)</A>
<strong>(FUNCTION)</strong>
<br>
<A NAME="gdImageCreateFromJpegCtx">gdImageCreateFromJpegCtx(gdIOCtx *in)</A>
<strong>(FUNCTION)</strong>
<p>
<DD>
gdImageCreateFromJpeg is called to load truecolor images from JPEG format files.
Invoke gdImageCreateFromJpeg with an already opened pointer to a file
containing the desired image.
gdImageCreateFromJpeg
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new 
truecolor image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain a JPEG image). gdImageCreateFromJpeg does <em>not</em>
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>. <strong>The
returned image is always a truecolor image.</strong> 
<p>
If you already have the
image file in memory, pass the size of the file and a pointer to the
file's data to gdImageCreateFromJpegPtr, which is otherwise identical
to gdImageCreateFromJpeg.
<p>
<PRE>
<A HREF="#gdImagePtr">gdImagePtr</A> im;
... inside a function ...
FILE *in;
in = fopen("myjpeg.jpg", "rb");
im = gdImageCreateFromJpeg(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCreateFromPng">gdImageCreateFromPng(FILE *in)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromPngPtr">gdImageCreateFromPngPtr(int size, void *data)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromPngCtx">gdImageCreateFromPngCtx(<a href=#gdioctx>gdIOCtx</a> *in)</A>
<strong>(FUNCTION)</strong>
<p>
<DD>
gdImageCreateFromPng is called to load images from PNG format files.
Invoke gdImageCreateFromPng with an already opened pointer to a file
containing the desired image.
gdImageCreateFromPng
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain a PNG image). gdImageCreateFromPng does <em>not</em>
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<p>
If you already have the
image file in memory, pass the size of the file and a pointer to the
file's data to gdImageCreateFromPngPtr, which is otherwise identical
to gdImageCreateFromPng.
<p>
If the PNG image being loaded is a truecolor image, the resulting
gdImagePtr will refer to a truecolor image. If the PNG image
being loaded is a palette or grayscale image, the resulting
gdImagePtr will refer to a palette image. gd retains only 8 bits
of resolution for each of the red, green and blue channels, and
only 7 bits of resolution for the alpha channel. The former
restriction affects only a handful of very rare 48-bit color
and 16-bit grayscale PNG images. The second restriction affects
all semitransparent PNG images, but the difference is essentially
invisible to the eye. 7 bits of alpha channel resolution is,
in practice, quite a lot.
<PRE>
<A HREF="#gdImagePtr">gdImagePtr</A> im;
... inside a function ...
FILE *in;
in = fopen("mypng.png", "rb");
im = gdImageCreateFromPng(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCreateFromPngSource">gdImageCreateFromPngSource(gdSourcePtr in)</A>
<strong>(FUNCTION)</strong>
<dd>
<b>Deprecated</b> in favor of
<a href="#gdImageCreateFromPngCtx">gdImageCreateFromPngCtx</a>. Should
not be used in new applications.
<p>
gdImageCreateFromPngSource is called to load a PNG from
a data source other than a file. Usage is very similar to
the <a href="#gdImageCreateFromPng">gdImageCreateFromPng</a> function,
except that the programmer provides a custom data source.
<p>
The programmer must write an input function which accepts
a context pointer, a buffer, and a number of bytes to be
read as arguments. This function must read the number of
bytes requested, unless the end of the file has been reached,
in which case the function should return zero, or an error
has occurred, in which case the function should return
<code>-1</code>. The programmer then creates a
<a href="#gdSource">gdSource</a> structure and sets
the <code>source</code> pointer to the input function and
the context pointer to any value which is useful to the
programmer.
<p>
The example below
implements <a href="#gdImageCreateFromPng">gdImageCreateFromPng</a>
by creating a custom data source and invoking gdImageCreateFromPngSource.
<pre>
static int freadWrapper(void *context, char *buf, int len);

gdImagePtr gdImageCreateFromPng(FILE *in)
{
        gdSource s;
        s.source = freadWrapper;
        s.context = in;
        return gdImageCreateFromPngSource(&s);
}

static int freadWrapper(void *context, char *buf, int len)
{
        int got = fread(buf, 1, len, (FILE *) context);
        return got;
}
</pre>
<DT><A NAME="gdImageCreateFromGif">gdImageCreateFromGif(FILE *in)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromGifPtr">gdImageCreateFromGifPtr(int size, void *data)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromGifCtx">gdImageCreateFromGifCtx(<a href=#gdioctx>gdIOCtx</a> *in)</A>
<strong>(FUNCTION)</strong>
<p>
<DD>
gdImageCreateFromGif is called to load images from GIF format files.
Invoke gdImageCreateFromGif with an already opened pointer to a file
containing the desired image.
gdImageCreateFromGif
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain a GIF image). gdImageCreateFromGif does <em>not</em>
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<p>
If you already have the
image file in memory, pass the size of the file and a pointer to the
file's data to gdImageCreateFromGifPtr, which is otherwise identical
to gdImageCreateFromGif.
<PRE>
<A HREF="#gdImagePtr">gdImagePtr</A> im;
... inside a function ...
FILE *in;
in = fopen("mygif.gif", "rb");
im = gdImageCreateFromGif(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCreateFromGd">gdImageCreateFromGd(FILE *in)</A>
<strong>(FUNCTION)</strong>
<br><DT><A NAME="gdImageCreateFromGdPtr">gdImageCreateFromGdPtr(int size, void *data)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromGdCtx">gdImageCreateFromGdCtx(<a href=#gdioctx>gdIOCtx</a> *in)</A>
<strong>(FUNCTION)</strong>
<p>
<DD>
gdImageCreateFromGd is called to load images from gd format files.
Invoke gdImageCreateFromGd
with an already opened pointer to a file containing the desired image
in the <A HREF="#gdformat">gd file format</A>, which is specific to
gd and intended for very fast loading. (It is <em>not</em> intended for
compression; for compression, use PNG or JPEG.)
<p>
If you already have the
image file in memory, pass the size of the file and a pointer to the
file's data to gdImageCreateFromGdPtr, which is otherwise identical
to gdImageCreateFromGd.
<p>
gdImageCreateFromGd
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain a gd format image). gdImageCreateFromGd does <em>not</em>
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
in = fopen("mygd.gd", "rb");
im = gdImageCreateFromGd(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>

<DT><A NAME="gdImageCreateFromGd2">gdImageCreateFromGd2(FILE *in)</A>
<strong>(FUNCTION)</strong>
<br><A NAME="gdImageCreateFromGd2Ptr">gdImageCreateFromGd2Ptr(int size, void *data)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromGd2Ctx">gdImageCreateFromGd2Ctx(<a href=#gdioctx>gdIOCtx</a> *in)</A>
<strong>(FUNCTION)</strong>
<p>

<DD>
gdImageCreateFromGd2 is called to load images from gd2 format files.
Invoke gdImageCreateFromGd2
with an already opened pointer to a file containing the desired image
in the <A HREF="#gdformat">gd2 file format</A>, which is specific to
gd2 and intended for fast loading of parts of large images. 
(It is a compressed format, but generally not as good as maximum
compression of the entire image would be.) 
<p>
If you already have the
image file in memory, pass the size of the file and a pointer to the
file's data to gdImageCreateFromGd2Ptr, which is otherwise identical
to gdImageCreateFromGd2.
<p>
gdImageCreateFromGd2
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain a gd format image). gdImageCreateFromGd2 does <em>not</em>
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
in = fopen("mygd.gd2", "rb");
im = gdImageCreateFromGd2(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>

<DT><A NAME="gdImageCreateFromGd2Part">gdImageCreateFromGd2Part(FILE *in, int srcX, int srcY, int w, int h)</A>
<strong>(FUNCTION)</strong>
<br><A NAME="gdImageCreateFromGd2PartPtr">gdImageCreateFromGd2PartPtr(int size, void *data, int srcX, int srcY, int w, int h)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromGd2PartCtx">gdImageCreateFromGd2PartCtx(<a href=#gdioctx>gdIOCtx</a> *in)</A>
<strong>(FUNCTION)</strong>
<p>

<DD>
gdImageCreateFromGd2Part is called to load parts of images from <A HREF="#gdformat">gd2 format files</a>.
Invoked in the same way as <a href=#gdImageCreateFromGd2>gdImageCreateFromGd2</a>,
but with extra parameters
indicating the source (x, y) and width/height of the desired image.
gdImageCreateFromGd2Part returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the
new image, or NULL if unable to load the image.
The image must eventually be destroyed using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<p>
If you already have the image file in memory, you may use
gdImageCreateFromGd2PartPtr. Pass the size of the image file,
in bytes, as the first argument and the pointer to the image file data
as the second argument.
<p>
<DT><A NAME="gdImageCreateFromWBMP">gdImageCreateFromWBMP(FILE *in)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromWBMPPtr">gdImageCreateFromWBMPPtr(int size, void *data)</A>
<strong>(FUNCTION)</strong>
<BR><A NAME="gdImageCreateFromWBMPCtx">gdImageCreateFromWBMPCtx(<a href=#gdioctx>gdIOCtx</a> *in)</A>
<strong>(FUNCTION)</strong>
<p>
<DD>
gdImageCreateFromWBMP is called to load images from WBMP format files.
Invoke gdImageCreateFromWBMP with an already opened pointer to a file
containing the desired image.
gdImageCreateFromWBMP
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain a PNG image). gdImageCreateFromWBMP does <em>not</em>
close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<p>
If you already have the
image file in memory, pass the size of the file and a pointer to the
file's data to gdImageCreateFromWBMPPtr, which is otherwise identical
to gdImageCreateFromWBMP.
<PRE>
<A HREF="#gdImagePtr">gdImagePtr</A> im;
... inside a function ...
FILE *in;
in = fopen("mywbmp.wbmp", "rb");
im = gdImageCreateFromWBMP(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<p>
<DT><A NAME="gdImageCreateFromXbm">gdImageCreateFromXbm(FILE *in)</A>
<strong>(FUNCTION)</strong>
<DD>
gdImageCreateFromXbm is called to load images from X bitmap format
files. Invoke gdImageCreateFromXbm
with an already opened pointer to a file containing the desired image.
gdImageCreateFromXbm
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain an X bitmap format image). gdImageCreateFromXbm does
<em>not</em> close the file. You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
in = fopen("myxbm.xbm", "rb");
im = gdImageCreateFromXbm(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCreateFromXpm">gdImageCreateFromXpm(char *filename)</A>
<strong>(FUNCTION)</strong>
<DD>
gdImageCreateFromXbm is called to load images from XPM X Window System
color bitmap format files. This function is available only if HAVE_XPM
is selected in the Makefile and the Xpm library is linked with the
application. Unlike most gd file functions, the Xpm functions require
filenames, not file pointers. 
gdImageCreateFromXpm
returns a <A HREF="#gdImagePtr">gdImagePtr</A> to the new image, or NULL
if unable to load the image (most often because the file is corrupt or
does not contain an XPM bitmap format image). You can inspect the sx and sy members of the
image to determine its size. The image must eventually be destroyed
using <A HREF="#gdImageDestroy">gdImageDestroy()</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
in = fopen("myxpm.xpm", "rb");
im = gdImageCreateFromXpm(in);
fclose(in);
/* ... Use the image ... */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageDestroy">gdImageDestroy(gdImagePtr im)</A> <STRONG>(FUNCTION)</STRONG>
<DD>gdImageDestroy is used to free the memory associated with
an image. It is important to invoke gdImageDestroy before
exiting your program or assigning a new image to
a <A HREF="#gdImagePtr">gdImagePtr</A> variable.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(10, 10);
/* ... Use the image ... */
/* Now destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageJpeg">
void gdImageJpeg(gdImagePtr im, FILE *out, int quality)</A>
<STRONG>(FUNCTION)</STRONG><BR>
<a name="gdImageJpegCtx">void gdImageJpegCtx(gdImagePtr im, gdIOCtx *out, int quality)</A>
<STRONG>(FUNCTION)</STRONG><BR>
<DD>
gdImageJpeg outputs the specified image to the specified
file in JPEG format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImageJpeg does <em>not</em>
close the file; your code must do so.
<P>
If quality is negative, the default IJG JPEG quality value (which
should yield a good general quality / size tradeoff for most
situations) is used.  Otherwise, for practical purposes, quality
should be a value in the range 0-95, higher quality values usually
implying both higher quality and larger image sizes.
<P>
If you have set image interlacing using
<A HREF="#gdImageInterlace">gdImageInterlace</A>, this function will
interpret that to mean you wish to output a progressive JPEG.  Some
programs (e.g., Web browsers) can display progressive JPEGs
incrementally; this can be useful when browsing over a relatively slow
communications link, for example.  Progressive JPEGs can also be
slightly smaller than sequential (non-progressive) JPEGs.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black, white;
FILE *out;
/* Create the image */
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Allocate background */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);
/* Allocate drawing color */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);
/* Draw rectangle */
<A HREF="#gdImageRectangle">gdImageRectangle</A>(im, 0, 0, 99, 99, black);
/* Open output file in binary mode */
out = fopen("rect.jpg", "wb");
/* Write JPEG using default quality */
gdImageJpeg(im, out, -1);
/* Close file */
fclose(out);
/* Destroy image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageJpegPtr">
void* gdImageJpegPtr(gdImagePtr im, int *size, int quality)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageJpeg except that it returns a pointer to a memory
area with the JPEG data. This memory must be freed by the caller when it is
no longer needed. <strong>The caller must invoke gdFree(), not free(), 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.</strong> The 'size' parameter receives the total size of the block
of memory.
<DT><A NAME="gdImageGif">
void gdImageGif(gdImagePtr im, FILE *out)</A>
<br>
<A NAME="gdImageGifCtx">
void gdImageGifCtx(gdImagePtr im, gdIOCtx *out)</A>

<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageGif outputs the specified image to the specified
file in GIF format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImageGif does <em>not</em>
close the file; your code must do so.
<p>
GIF does not support true color; GIF images can contain a maximum
of 256 colors. If the image to be written is a 
truecolor image, such as those created with 
<a href="#gdImageCreateTrueColor">gdImageCreateTrueColor</a> or loaded 
from a JPEG or a truecolor PNG image file, a palette-based
temporary image will automatically be created internally using the 
<a href="#gdImageCreatePaletteFromTrueColor">gdImageCreatePaletteFromTrueColor</a> function. The original image pixels are not modified. This conversion
produces high quality palettes but does require some CPU time. If you are
regularly converting truecolor to palette in this way, you should consider
creating your image as a palette-based image in the first place.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black, white;
FILE *out;
/* Create the image */
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Allocate background */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);
/* Allocate drawing color */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);
/* Draw rectangle */
<A HREF="#gdImageRectangle">gdImageRectangle</A>(im, 0, 0, 99, 99, black);
/* Open output file in binary mode */
out = fopen("rect.gif", "wb");
/* Write GIF */
gdImageGif(im, out);
/* Close file */
fclose(out);
/* Destroy image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageGifPtr">
void* gdImageGifPtr(gdImagePtr im, int *size)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageGif except that it returns a pointer to a memory
area with the GIF data. This memory must be freed by the caller when it is
no longer needed. <strong>The caller must invoke gdFree(), not free(), 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.</strong> The 'size' parameter receives the total size of the block
of memory.

<DT><A NAME="gdImageGifAnimBegin">
void gdImageGifAnimBegin(gdImagePtr im, FILE *out, int GlobalCM, int Loops)</A>
<br>
<A NAME="gdImageGifAnimBeginCtx">
void gdImageGifAnimBeginCtx(gdImagePtr im, gdIOCtx *out, int GlobalCM, int Loops)</A>

<STRONG>(FUNCTION)</STRONG>

<DD>This function must be called as the first function when creating a
GIF animation.  It writes the correct GIF file headers to selected
file output, and prepares for frames to be added for the animation.
The image argument is not used to produce an image frame to the file,
it is only used to establish the GIF animation frame size, interlacing
options and the color palette.  gdImageGifAnimAdd is used to
add the first and subsequent frames to the animation, and the animation
must be terminated by writing a semicolon character (;) to it or by using
gdImageGifAnimEnd to do that.
<p>

The GlobalCM flag indicates if a global color map (or palette) is used
in the GIF89A header.  A nonzero value specifies that a global color
map should be used to reduce the size of the animation.
Of course, if the color maps of
individual frames differ greatly, a global color map may not be a good idea.
GlobalCM=1 means write global color map, GlobalCM=0 means do not, and
GlobalCM=-1 means to do the default, which currently is to use a global
color map.

<p>

If Loops is 0 or greater, the Netscape 2.0 extension for animation
loop count is written.  0 means infinite loop count.  -1 means that
the extension is not added which results in no looping. -1 is the
default.

<DT><A NAME="gdImageGifAnimBeginPtr">
void* gdImageGifAnimBeginPtr(gdImagePtr im, int *size, int GlobalCM, int Loops)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageGifAnimBegin except that it returns a pointer
to a memory area with the GIF data. This memory must be freed by the
caller when it is no longer needed. <strong>The caller must invoke
gdFree(), not free(), unless the caller is absolutely certain that the
same implementations of malloc, free, etc. are used both at library
build time and at application build time.</strong> The 'size'
parameter receives the total size of the block of memory.

<DT><A NAME="gdImageGifAnimAdd">
void gdImageGifAnimAdd(gdImagePtr im, FILE *out, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm)</A>
<br>
<A NAME="gdImageGifAnimAddCtx">
void gdImageGifAnimAddCtx(gdImagePtr im, gdIOCtx *out, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm)</A>

<STRONG>(FUNCTION)</STRONG>

<DD> This function writes GIF animation frames to GIF animation, which
was initialized with <a
href="#gdImageGifAnimBegin">gdImageGifAnimBegin</a>.  With LeftOfs and
TopOfs you can place this frame in different offset than (0,0) inside
the image screen as defined in gdImageGifAnimBegin.  Delay between the
previous frame and this frame is in 1/100s units.  Disposal is usually
<code>gdDisposalNone</code>, meaning that the pixels changed by this
frame should remain on the display when the next frame begins to render, but
can also be <code>gdDisposalUnknown</code> (not recommended),
<code>gdDisposalRestoreBackground</code> (restores the first
allocated color of the global palette), or
<code>gdDisposalRestorePrevious</code> (restores the appearance of the
affected area before the frame was rendered). Only
<code>gdDisposalNone</code> is a sensible choice for the first frame.
If <code>previm</code> is
passed, the built-in GIF optimizer will always use <code>gdDisposalNone</code> 
regardless of the Disposal parameter.
<p>
Setting the LocalCM flag to 1 adds a local palette for this image to the 
animation.  Otherwise the global palette is assumed and the user must make 
sure the palettes match.  Use <A HREF="#gdImagePaletteCopy">gdImagePaletteCopy</A> to do that.

<p>

Automatic optimization is activated by giving the previous image as a 
parameter.  This function then compares the images and only writes the changed
pixels to the new frame in animation.  The Disposal parameter for
optimized animations must be set to 1, also for the first frame.
LeftOfs and TopOfs parameters are ignored for optimized frames.  To
achieve good optimization, it is usually best to use a single global 
color map.  To allow gdImageGifAnimAdd to compress unchanged pixels via
the use of a transparent color, the image must include a transparent color.

<PRE>
... inside a function ...
gdImagePtr im, im2, im3;
int black, white, trans;
FILE *out;
/* Create the image */
im = gdImageCreate(100, 100);
/* Allocate background */
white = gdImageColorAllocate(im, 255, 255, 255);
/* Allocate drawing color */
black = gdImageColorAllocate(im, 0, 0, 0);
/* Allocate transparent color for animation compression */
trans = gdImageColorAllocate(im, 1, 1, 1);
/* Draw rectangle */
gdImageRectangle(im, 0, 0, 10, 10, black);
/* Open output file in binary mode */
out = fopen("anim.gif", "wb");
/* Write GIF header.  Use global color map.  Loop a few times */
gdImageGifAnimBegin(im, out, 1, 3);
/* Write the first frame.  No local color map.  Delay = 1s */
gdImageGifAnimAdd(im, out, 0, 0, 0, 100, 1, NULL);
/* construct the second frame */
im2 = gdImageCreate(100, 100);
/* Allocate background to make it white */
(void)gdImageColorAllocate(im2, 255, 255, 255);
/* Make sure the palette is identical */
gdImagePaletteCopy (im2, im);
/* Draw something */
gdImageRectangle(im2, 0, 0, 15, 15, black);
/* Allow animation compression with transparent pixels */
gdImageColorTransparent (im2, trans);
/* Add the second frame */
gdImageGifAnimAdd(im2, out, 0, 0, 0, 100, 1, im);
/* construct the second frame */
im3 = gdImageCreate(100, 100);
/* Allocate background to make it white */
(void)gdImageColorAllocate(im3, 255, 255, 255);
/* Make sure the palette is identical */
gdImagePaletteCopy (im3, im);
/* Draw something */
gdImageRectangle(im3, 0, 0, 15, 20, black);
/* Allow animation compression with transparent pixels */
gdImageColorTransparent (im3, trans);
/* Add the third frame, compressing against the second one */
gdImageGifAnimAdd(im3, out, 0, 0, 0, 100, 1, im2);
/* Write the end marker */
/* gdImageGifAnimEnd(out); is the same as the following: */
putc (';', out);
/* Close file */
fclose(out);
/* Destroy images */
gdImageDestroy(im);
gdImageDestroy(im2);
gdImageDestroy(im3);
</PRE>

<DT><A NAME="gdImageGifAnimAddPtr">
void* gdImageGifAnimAddPtr(gdImagePtr im, int *size, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageGifAnimAdd except that it returns a pointer
to a memory area with the GIF data. This memory must be freed by the
caller when it is no longer needed. <strong>The caller must invoke
gdFree(), not free(), unless the caller is absolutely certain that the
same implementations of malloc, free, etc. are used both at library
build time and at application build time.</strong> The 'size'
parameter receives the total size of the block of memory.

<DT><A NAME="gdImageGifAnimEnd">
void gdImageGifAnimEnd(FILE *out)</A>
<br>
<A NAME="gdImageGifAnimEndCtx">
void gdImageGifAnimEndCtx(gdIOCtx *out)</A>

<STRONG>(FUNCTION)</STRONG>

<DD>Writes semicolon character (;) to the output file.  This
terminates the GIF file properly.  You can omit the call to
gdImageGifAnimEnd and just print out the semicolon.

<DT><A NAME="gdImageGifAnimEndPtr">
void* gdImageGifAnimEndPtr(int *size)</A>
<STRONG>(FUNCTION)</STRONG>

<DD>Returns a one byte string containing the semicolon character (;).
Returns a pointer to a memory area with that string. This memory must
be freed by the caller when it is no longer needed. <strong>The caller
must invoke gdFree(), not free(), unless the caller is absolutely
certain that the same implementations of malloc, free, etc. are used
both at library build time and at application build time.</strong> The
'size' parameter receives the total size of the block of memory.  The
string ";" can be used in place of this function.

<DT><A NAME="gdImagePng">
void gdImagePng(gdImagePtr im, FILE *out)</A>
<br>
<A NAME="gdImagePngCtx">
void gdImagePngCtx(gdImagePtr im, gdIOCtx *out)</A>

<STRONG>(FUNCTION)</STRONG>
<DD>
gdImagePng outputs the specified image to the specified
file in PNG format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImagePng does <em>not</em>
close the file; your code must do so.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black, white;
FILE *out;
/* Create the image */
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Allocate background */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);
/* Allocate drawing color */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);
/* Draw rectangle */
<A HREF="#gdImageRectangle">gdImageRectangle</A>(im, 0, 0, 99, 99, black);
/* Open output file in binary mode */
out = fopen("rect.png", "wb");
/* Write PNG */
gdImagePng(im, out);
/* Close file */
fclose(out);
/* Destroy image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImagePngEx">
void gdImagePngEx(gdImagePtr im, FILE *out, int level)</A>
<br>
<A NAME="gdImagePngCtxEx">
void gdImagePngCtxEx(gdImagePtr im, gdIOCtx *out, int level)</A>

<STRONG>(FUNCTION)</STRONG>
<DD>
Like <a href="#gdImagePng">gdImagePng</a>, gdImagePngEx outputs the 
specified image to the specified file in PNG format. In addition,
gdImagePngEx allows the level of compression to be specified. A compression
level of 0 means "no compression." A compression level of 1 means
"compressed, but as quickly as possible." A compression level of 9
means "compressed as much as possible to produce the smallest possible
file." A compression level of -1 will use the default compression level
at the time zlib was compiled on your system.
<p>
For more information, see <a href="#gdImagePng">gdImagePng</a>.
<DT><A NAME="gdImagePngPtr">
void* gdImagePngPtr(gdImagePtr im, int *size)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImagePng except that it returns a pointer to a memory
area with the PNG data. This memory must be freed by the caller when it is
no longer needed. <strong>The caller must invoke gdFree(), not free(), 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.</strong> The 'size' parameter receives the total size of the block
of memory.
<DT><A NAME="gdImagePngPtrEx">
void* gdImagePngPtrEx(gdImagePtr im, int *size, int level)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
Like <a href="#gdImagePngPtr">gdImagePngPtr</a>, gdImagePngPtrEx returns a
pointer to a PNG image in allocated memory.
In addition, gdImagePngPtrEx allows the level of compression to be 
specified. A compression level of 0 means "no compression." A compression level of 1 means
"compressed, but as quickly as possible." A compression level of 9
means "compressed as much as possible to produce the smallest possible
file." A compression level of -1 will use the default compression level
at the time zlib was compiled on your system.
<p>
For more information, see <a href="#gdImagePngPtr">gdImagePngPtr</a>.
<DT><A NAME="gdImagePngToSink">gdImagePngToSink(gdImagePtr im, gdSinkPtr out)</A>
<strong>(FUNCTION)</strong>
<dd>
gdImagePngToSink is called to write a PNG to
a data "sink" (destination) other than a file. Usage is very similar to
the <a href="#gdImagePng">gdImagePng</a> function,
except that the programmer provides a custom data sink.
<p>
The programmer must write an output function which accepts
a context pointer, a buffer, and a number of bytes to be
written as arguments. This function must write the number of
bytes requested and return that number, unless an error
has occurred, in which case the function should return
<code>-1</code>. The programmer then creates a
<a href="#gdSink">gdSink</a> structure and sets
the <code>sink</code> pointer to the output function and
the context pointer to any value which is useful to the
programmer.
<p>
The example below
implements <a href="#gdImagePng">gdImagePng</a>
by creating a custom data source and invoking gdImagePngFromSink.
<pre>
static int stdioSink(void *context, char *buffer, int len)
{
  return fwrite(buffer, 1, len, (FILE *) context);
}

void gdImagePng(gdImagePtr im, FILE *out)
{
  gdSink mySink;
  mySink.context = (void *) out;
  mySink.sink = stdioSink;
  gdImagePngToSink(im, &mySink);
}
</pre>
<DT><A NAME="gdImageWBMP">
void gdImageWBMP(gdImagePtr im, int fg, FILE *out)</A>
<BR><A NAME="gdImageWBMPCtx">gdImageWBMPCtx(<a href=#gdioctx>gdIOCtx</a> *out)</A>
<strong>(FUNCTION)</strong><STRONG>(FUNCTION)</STRONG>
<DD>
gdImageWBMP outputs the specified image to the specified
file in WBMP format. The file must be open for writing. Under MSDOS
and all versions of Windows, it is important to use "wb" as opposed
to simply "w" as the mode when opening the file, and under Unix there
is no penalty for doing so. gdImageWBMP does <em>not</em>
close the file; your code must do so.
<p>
<strong>WBMP file support is black and white only. The color index
specified by the fg argument is the "foreground," and only pixels
of this color will be set in the WBMP file.</strong> All other pixels
will be considered "background."
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black, white;
FILE *out;
/* Create the image */
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Allocate background */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);
/* Allocate drawing color */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);
/* Draw rectangle */
<A HREF="#gdImageRectangle">gdImageRectangle</A>(im, 0, 0, 99, 99, black);
/* Open output file in binary mode */
out = fopen("rect.wbmp", "wb");
/* Write WBMP, with black as foreground */
gdImageWBMP(im, black, out);
/* Close file */
fclose(out);
/* Destroy image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageWBMPPtr">
void* gdImageWBMPPtr(gdImagePtr im, int *size)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageWBMP except that it returns a pointer to a memory
area with the WBMP data. This memory must be freed by the caller when it is
no longer needed. <strong>The caller must invoke gdFree(), not free(), 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.</strong> The 'size' parameter receives the total size of the block
of memory.
<DT><A NAME="gdImageGd">
void gdImageGd(gdImagePtr im, FILE *out)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageGd outputs the specified image to the specified
file in the <A HREF="#gdformat">gd image format</A>. The file must
be open for writing. Under MSDOS and all versions of Windows, it is
important to use "wb" as
opposed to simply "w" as the mode when opening the file, and under
Unix there is no penalty for doing so. gdImagePng does <em>not</em>
close the file; your code must do so.
<P>
The gd image format is intended for fast reads and writes of
images your program will need frequently to build other
images. It is <em>not</em> a compressed format, and is not intended
for general use.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black, white;
FILE *out;
/* Create the image */
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Allocate background */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);
/* Allocate drawing color */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);
/* Draw rectangle */
<A HREF="#gdImageRectangle">gdImageRectangle</A>(im, 0, 0, 99, 99, black);
/* Open output file in binary mode */
out = fopen("rect.gd", "wb");
/* Write gd format file */
gdImageGd(im, out);
/* Close file */
fclose(out);
/* Destroy image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>

<DT><A NAME="gdImageGdPtr">
void* gdImageGdPtr(gdImagePtr im, int *size)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageGd except that it returns a pointer to a memory
area with the GD data. This memory must be freed by the caller when it is
no longer needed. <strong>The caller must invoke gdFree(), not free(), 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.</strong> The 'size' parameter receives the total size of the block
of memory.

<DT><A NAME="gdImageGd2">
void gdImageGd2(gdImagePtr im, FILE *out, int chunkSize, int fmt)</A>
<br>
<A NAME="gdImageGd2Ctx">
void gdImageGd2Ctx(gdImagePtr im, gdIOCtx *out, int chunkSize, int fmt)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageGd2 outputs the specified image to the specified
file in the <A HREF="#gd2format">gd2 image format</A>. The file must
be open for writing. Under MSDOS and all versions of Windows, it is
important to use "wb" as
opposed to simply "w" as the mode when opening the file, and under
Unix there is no penalty for doing so. gdImageGd2 does <em>not</em>
close the file; your code must do so.
<P>
The gd2 image format is intended for fast reads and writes of
parts of images.
It is a compressed format, and well suited to retrieving smll sections of
much larger images.

The third and fourth parameters are the 'chunk size' and format resposectively.
<p>
The file is stored as a series of compressed subimages, and the
<strong>Chunk Size</strong> determines the sub-image size - a value of
zero causes the GD library to use the default.
<p>
It is also possible to store GD2 files in an uncompressed format, in which case the
fourth parameter should be GD2_FMT_RAW.

<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black, white;
FILE *out;
/* Create the image */
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Allocate background */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);
/* Allocate drawing color */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);
/* Draw rectangle */
<A HREF="#gdImageRectangle">gdImageRectangle</A>(im, 0, 0, 99, 99, black);
/* Open output file in binary mode */
out = fopen("rect.gd", "wb");
/* Write gd2 format file */
gdImageGd2(im, out, 0, GD2_FMT_COMPRESSED);
/* Close file */
fclose(out);
/* Destroy image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>

<DT><A NAME="gdImageGd2Ptr">
void* gdImageGd2Ptr(gdImagePtr im, int chunkSize, int fmt, int *size)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>Identical to gdImageGd2 except that it returns a pointer to a memory
area with the GD2 data. This memory must be freed by the caller when it is
no longer needed. <strong>The caller must invoke gdFree(), not free(), 
unless the caller is absolutely certain that the same implementations of
malloc, free, etc. are used both at library build time and at application
build time.</strong> The 'size' parameter receives the total size of the block
of memory.
<DT><A NAME="gdImageTrueColorToPalette">
void gdImageTrueColorToPalette(gdImagePtr im, int ditherFlag, int colorsWanted)</A>
<br>
<A NAME="gdImageCreatePaletteFromTrueColor">
gdImagePtr gdImageCreatePaletteFromTrueColor(gdImagePtr im, int ditherFlag, int colorsWanted)</A>

<STRONG>(FUNCTION)</STRONG>
<DD>
<blockquote>
gdImageCreatePaletteFromTrueColor returns a <b>new</b> 
image. gdImageTrueColorToPalette permanently converts the
<b>existing</b> image. The two functions are otherwise identical.
</blockquote>
<p>
The function converts a truecolor image to a palette-based image,
using a high-quality two-pass quantization routine.
If ditherFlag is set, the image will be
dithered to approximate colors better, at the expense
of some obvious "speckling." colorsWanted can be
anything up to 256. If the original source image
includes photographic information or anything that
came out of a JPEG, 256 is strongly recommended. 
100% transparency of a single transparent color in the
original truecolor image will be preserved. There is no other
support for preservation of alpha channel or transparency in
the destination image.
<p>
For best results, don't use this function -- write real
truecolor PNGs and JPEGs. The disk space gain of
conversion to palette is not great (for small images
it can be negative) and the quality loss is ugly. However,
the version of this function included in version 2.0.12 and later does
do a better job than the version included prior to 2.0.12.
</DL>
<H3><A NAME="drawing">Drawing Functions</A></H3>
<DL>
<DT><A NAME="gdImageSetPixel">void gdImageSetPixel(gdImagePtr im, int x, int y, int color)</A> <STRONG>(FUNCTION)</STRONG>
<DD>gdImageSetPixel sets a pixel to a particular color index. Always use
this function or one of the other drawing functions to access pixels;
do not access the pixels of the <A HREF="#gdImage">gdImage</A> structure
directly.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Set a pixel near the center. */
gdImageSetPixel(im, 50, 50, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageLine">void gdImageLine(gdImagePtr im, int x1, int y1, int x2, int y2, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageLine is used to draw a line between two endpoints (x1,y1 and x2, y2).
The line is drawn using the color index specified. Note that the color
index can be an actual color returned by <A HREF="#gdImageColorAllocate">
gdImageColorAllocate</A> or one of <A HREF="#gdStyled">gdStyled</A>,
<A HREF="#gdBrushed">gdBrushed</A> or <A HREF="#gdStyledBrushed">
gdStyledBrushed</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green 
  and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a line from the upper left corner to the 
  lower right corner. */
gdImageLine(im, 0, 0, 99, 99, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageDashedLine">void gdImageDashedLine(gdImagePtr im, int x1, int y1, int x2, int y2, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageDashedLine is provided <strong>solely for backwards compatibility
</strong> with gd 1.0. New programs should draw dashed lines using
the normal <A HREF="#gdImageLine">gdImageLine</A> function and the
new <A HREF="#gdImageSetStyle">gdImageSetStyle</A> function.
<P>
gdImageDashedLine is used to draw a dashed line between two endpoints
(x1,y1 and x2, y2).
The line is drawn using the color index specified. The portions of the line
that are not drawn are left transparent so the background is visible.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue 
  all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a dashed line from the upper left corner 
  to the lower right corner. */
gdImageDashedLine(im, 0, 0, 99, 99);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImagePolygon">void gdImagePolygon(gdImagePtr im, gdPointPtr points, int pointsTotal, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImagePolygon is used to draw a polygon with the verticies
(at least 3) specified, using the color index specified.
See also <A HREF="#gdImageFilledPolygon">gdImageFilledPolygon</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
/* Points of polygon */
<A HREF="#gdPoint">gdPoint</A> points[3];
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and 
  blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a triangle. */
points[0].x = 50;
points[0].y = 0;
points[1].x = 99;
points[1].y = 99;
points[2].x = 0;
points[2].y = 99;
gdImagePolygon(im, points, 3, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageOpenPolygon">void gdImageOpenPolygon(gdImagePtr im, gdPointPtr points, int pointsTotal, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageOpenPolygon is used to draw a sequence of lines with the verticies
(at least 3) specified, using the color index specified.  Unlike
<A HREF="#gdImagePolygon">gdImagePolygon</A>, the enpoints of the line
sequence are not connected to a closed polygon.
<DT><A NAME="gdImageRectangle">void gdImageRectangle(gdImagePtr im, int x1, int y1, int x2, int y2, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageRectangle is used to draw a rectangle with the two corners
(upper left first, then lower right) specified, using the
color index specified.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a rectangle occupying the central area. */
gdImageRectangle(im, 25, 25, 74, 74, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageFilledPolygon">void gdImageFilledPolygon(gdImagePtr im, gdPointPtr points, int pointsTotal, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageFilledPolygon is used to fill a polygon with the verticies
(at least 3) specified, using the color index specified.
See also <A HREF="#gdImageFilledPolygon">gdImagePolygon</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
int red;
/* Points of polygon */
<A HREF="#gdPoint">gdPoint</A> points[3];
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Allocate the color red. */
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* Draw a triangle. */
points[0].x = 50;
points[0].y = 0;
points[1].x = 99;
points[1].y = 99;
points[2].x = 0;
points[2].y = 99;
/* Paint it in white */
gdImageFilledPolygon(im, points, 3, white);
/* Outline it in red; must be done second */
<A HREF="#gdImagePolygon">gdImagePolygon</A>(im, points, 3, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageFilledRectangle">void gdImageFilledRectangle(gdImagePtr im, int x1, int y1, int x2, int y2, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageFilledRectangle is used to draw a solid rectangle with the two corners
(upper left first, then lower right) specified, using the
color index specified.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">int gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a filled rectangle occupying the central area. */
gdImageFilledRectangle(im, 25, 25, 74, 74, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageArc">void gdImageArc(gdImagePtr im, int cx, int cy, int w, int h, int s, int e, int color)</A>
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageArc is used to draw a partial ellipse centered at the given point,
with the specified width and height in pixels. The arc begins at
the position in degrees specified by <code>s</code> and ends at
the position specified by <code>e</code>. The arc is drawn in
the color specified by the last argument. A circle can be drawn
by beginning from 0 degrees and ending at 360 degrees, with
width and height being equal. e must be greater than s. Values greater
than 360 are interpreted modulo 360.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 50);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Inscribe an ellipse in the image. */
gdImageArc(im, 50, 25, 98, 48, 0, 360, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageFilledArc">void gdImageFilledArc(gdImagePtr im, int cx, int cy, int w, int h, int s, int e, int color, int style)</A>
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageFilledArc is used to draw a partial ellipse centered at the given point,
with the specified width and height in pixels. The arc begins at
the position in degrees specified by <code>s</code> and ends at
the position specified by <code>e</code>. The arc is filled in
the color specified by the second to last argument. A circle can be drawn
by beginning from 0 degrees and ending at 360 degrees, with
width and height being equal. e must be greater than s. Values greater
than 360 are interpreted modulo 360. The last argument is a bitwise
OR of the following possibilities:
<ul>
<li>gdArc
<li>gdChord
<li>gdPie (synonym for gdChord)
<li>gdNoFill
<li>gdEdged
</ul>
gdArc and gdChord are mutually exclusive;
gdChord just connects the starting and ending
angles with a straight line, while gdArc produces
a rounded edge. gdPie is a synonym for gdArc.
gdNoFill indicates that the arc or chord should be
outlined, not filled. gdEdged, used together with
gdNoFill, indicates that the beginning and ending
angles should be connected to the center; this is
a good way to outline (rather than fill) a
'pie slice'.

<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 50);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Inscribe a filled pie slice in the image. */
gdImageFilledArc(im, 50, 25, 98, 48, 0, 45, white, gdArc);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageFilledEllipse">void gdImageFilledEllipse(gdImagePtr im, int cx, int cy, int w, int h, int color)</A>
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageFilledEllipse is used to draw an ellipse centered at the given point,
with the specified width and height in pixels. The ellipse is filled in
the color specified by the last argument. 
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 50);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Inscribe a filled ellipse in the image. */
gdImageFilledEllipse(im, 50, 25, 98, 48, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageFillToBorder">void gdImageFillToBorder(gdImagePtr im, int x, int y, int border, int color)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageFillToBorder floods a portion of the image with the specified
<code>color</code>, beginning at the specified point and stopping at
the specified <code>border</code> color. For a way of flooding an
area defined by the color of the starting point, see
<A HREF="#gdImageFill">gdImageFill</A>.
<P>
The border color <em>cannot</em> be a special color
such as <A HREF="#gdTiled">gdTiled</A>; it must be a proper
solid color. The fill color can be, however.
<P>
Note that gdImageFillToBorder is recursive. It is not the most
naive implementation possible, and the implementation is
expected to improve, but there will always be degenerate
cases in which the stack can become very deep. This can be
a problem in MSDOS and MS Windows 3.1 environments. (Of course,
in a Unix or Windows 95/98/NT environment with a proper stack, this is
not a problem at all.)
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
int red;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 50);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Allocate the color red. */
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* Inscribe an ellipse in the image. */
gdImageArc(im, 50, 25, 98, 48, 0, 360, white);
/* Flood-fill the ellipse. Fill color is red, border color is
  white (ellipse). */
gdImageFillToBorder(im, 50, 50, white, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageFill">void gdImageFill(gdImagePtr im, int x, int y, int color)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageFill floods a portion of the image with the specified
<code>color</code>, beginning at the specified point and flooding the
surrounding region of the same color as the starting point.
For a way of flooding a region defined by a specific border
color rather than by its interior color, see
<A HREF="#gdImageFillToBorder">gdImageFillToBorder</A>.
<P>
The fill color can be <A HREF="#gdTiled">gdTiled</A>, resulting
in a tile fill using another image as the tile. However,
the tile image cannot be transparent. If the image you wish
to fill with has a transparent color index, call
<A HREF="#gdImageTransparent">gdImageTransparent</A> on the
tile image and set the transparent color index to -1
to turn off its transparency.
<P>
Note that gdImageFill is recursive. It is not the most
naive implementation possible, and the implementation is
expected to improve, but there will always be degenerate
cases in which the stack can become very deep. This can be
a problem in MSDOS and MS Windows environments. (Of course,
in a Unix or Windows 95/98/NT environment with a proper stack, this is
not a problem at all.)
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
int red;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 50);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Allocate the color red. */
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* Inscribe an ellipse in the image. */
gdImageArc(im, 50, 25, 98, 48, 0, 360, white);
/* Flood-fill the ellipse. Fill color is red, and will replace the
  black interior of the ellipse. */
gdImageFill(im, 50, 50, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageSetAntiAliased">void gdImageSetAntiAliased(gdImagePtr im, int c)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
"Antialiasing" is a process by which jagged edges associated with line
drawing can be reduced by blending the foreground color with an appropriate
percentage of the background, depending on how much of the pixel in question
is actually within the boundaries of the line being drawn. 
All line-drawing functions,
such as <A HREF="#gdImageLine">gdImageLine</A>,
<A HREF="#gdImageOpenPolygon">gdImageOpenPolygon</A> and
<A HREF="#gdImagePolygon">gdImagePolygon</A>, will draw antialiased lines
if the special "color" <A HREF="#gdAntiAliased">
gdAntiAliased</A> is used when calling them.
<P>
gdImageSetAntiAliased is used to specify the actual foreground color
to be used when drawing antialiased lines. You may set any color to
be the foreground, however as of version 2.0.12 an alpha channel
component is not supported. 
<p>
Antialiased lines can be drawn on both truecolor and palette-based
images. However, attempts to draw antialiased lines on 
highly complex palette-based backgrounds may not give satisfactory
results, due to the limited number of colors available in the
palette. Antialiased line-drawing on simple backgrounds should
work well with palette-based images; otherwise create or fetch
a truecolor image instead.
<P>
You need not take any special action when you are finished
with antialised line drawing.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im, brush;
int black;
int blue;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
blue = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 255);
gdImageSetAntiAliased(im, blue);
/* Draw a smooth line from the upper left corner to the 
  lower right corner. */
<A HREF="#gdImageLine">gdImageLine</A>(im, 0, 0, 99, 99, <A HREF="#gdBrushed">gdAntiAliased</A>);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
See also <a href="#gdAntiAliased">gdAntiAliased</a> and
<a href="#gdSetAntiAliasedDontBlend">gdSetAntiAliasedDontBlend</a>.
<DT><A NAME="gdImageSetAntiAliasedDontBlend">void gdImageSetAntiAliasedDontBlend(gdImagePtr im, int c)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
Normally, when drawing lines with the special
<a href="#gdAntiAliased">gdAntiAliased</a> "color," blending with the 
background to reduce jagged edges is the desired behavior. However, when
it is desired that lines not be blended with one particular color when
it is encountered in the background, the 
gdImageSetAntiAliasedDontBlend function can be used to indicate the
special color that the foreground should stand out more clearly against.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im, brush;
int black;
int blue;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
blue = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 255);
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);

gdImageSetAntiAliased(im, blue);
/* The portion of the line that crosses this white rectangle will
  not be blended smoothly */
gdImageSetAntiAliasedDontBlend(im, white);
gdImageFilledRectangle(im, 25, 25, 75, 75, white);
/* Draw a smooth line from the upper left corner 
  to the lower right corner. */
<A HREF="#gdImageLine">gdImageLine</A>(im, 0, 0, 99, 99, <A HREF="#gdBrushed">gdAntiAliased</A>);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
See also <a href="#gdAntiAliased">gdAntiAliased</a> and
<a href="#gdSetAntiAliased">gdSetAntiAliased</a>.
<DT><A NAME="gdImageSetBrush">void gdImageSetBrush(gdImagePtr im, gdImagePtr brush)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
A "brush" is an image used to draw wide, shaped strokes in another image. Just
as a paintbrush is not a single point, a brush image need not be
a single pixel. <em>Any</em> gd image can be used as a brush, and by
setting the transparent color index of the brush image with
<A HREF="#gdImageColorTransparent">gdImageColorTransparent</A>,
a brush of any shape can be created. All line-drawing functions,
such as <A HREF="#gdImageLine">gdImageLine</A>,
<A HREF="#gdImageOpenPolygon">gdImageOpenPolygon</A> and
<A HREF="#gdImagePolygon">gdImagePolygon</A>, will use the
current brush if the special "color" <A HREF="#gdBrushed">
gdBrushed</A> or <A HREF="#gdStyledBrushed">gdStyledBrushed</A>
is used when calling them.
<P>
gdImageSetBrush is used to specify the brush to be used in a
particular image. You can set any image to be the brush.
If the brush image does not have the same color map as the
first image, any colors missing from the first image
will be allocated. If not enough colors can be allocated,
the closest colors already available will be used. This
allows arbitrary PNGs to be used as brush images. It also
means, however, that you should not set a brush unless you
will actually use it; if you set a rapid succession of
different brush images, you can quickly fill your color map,
and the results will not be optimal.
<P>
You need not take any special action when you are finished
with a brush. As for any other image, if you will not
be using the brush image for any further purpose,
you should call <A HREF="#gdImageDestroy">gdImageDestroy</A>.
You must not use the color <A HREF="#gdBrushed">gdBrushed</A>
if the current brush has been destroyed; you can of
course set a new brush to replace it.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im, brush;
FILE *in;
int black;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Open the brush PNG. For best results, portions of the
  brush that should be transparent (ie, not part of the
  brush shape) should have the transparent color index. */
in = fopen("star.png", "rb");
brush = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
gdImageSetBrush(im, brush);
/* Draw a line from the upper left corner to the lower right corner
  using the brush. */
<A HREF="#gdImageLine">gdImageLine</A>(im, 0, 0, 99, 99, <A HREF="#gdBrushed">gdBrushed</A>);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
/* Destroy the brush image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(brush);
</PRE>
<DT><A NAME="gdImageSetTile">void gdImageSetTile(gdImagePtr im, gdImagePtr tile)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
A "tile" is an image used to fill an area with  a repeated pattern.
<em>Any</em> gd image can be used as a tile, and by
setting the transparent color index of the tile image with
<A HREF="#gdImageColorTransparent">gdImageColorTransparent</A>,
a tile that allows certain parts of the underlying area to shine
through can be created. All region-filling functions,
such as <A HREF="#gdImageFill">gdImageFill</A> and
<A HREF="#gdImageFilledPolygon">gdImageFilledPolygon</A>, will use the
current tile if the special "color" <A HREF="#gdTiled">
gdTiled</A> is used when calling them.
<P>
gdImageSetTile is used to specify the tile to be used in a
particular image. You can set any image to be the tile.
If the tile image does not have the same color map as the
first image, any colors missing from the first image
will be allocated. If not enough colors can be allocated,
the closest colors already available will be used. This
allows arbitrary PNGs to be used as tile images. It also
means, however, that you should not set a tile unless you
will actually use it; if you set a rapid succession of
different tile images, you can quickly fill your color map,
and the results will not be optimal.
<P>
You need not take any special action when you are finished
with a tile. As for any other image, if you will not
be using the tile image for any further purpose,
you should call <A HREF="#gdImageDestroy">gdImageDestroy</A>.
You must not use the color <A HREF="#gdBrushed">gdTiled</A>
if the current tile has been destroyed; you can of
course set a new tile to replace it.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im, tile;
FILE *in;
int black;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Open the tile PNG. For best results, portions of the
  tile that should be transparent (ie, allowing the
  background to shine through) should have the transparent
  color index. */
in = fopen("star.png", "rb");
tile = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
gdImageSetTile(im, tile);
/* Fill an area using the tile. */
<A HREF="#gdImageFilledRectangle">gdImageFilledRectangle</A>(im, 25, 25, 75, 75, <A HREF="#gdTiled">gdTiled</A>);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
/* Destroy the tile image */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(tile);
</PRE>
<DT><A NAME="gdImageSetStyle">void gdImageSetStyle(gdImagePtr im, int *style, int styleLength)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
It is often desirable to draw dashed lines, dotted lines, and other
variations on a broken line. gdImageSetStyle can be used to set
any desired series of colors, including a special color that
leaves the background intact, to be repeated during the drawing
of a line.
<P>
To use gdImageSetStyle, create an array of integers and assign
them the desired series of color values to be repeated.
You can assign the special color value <A HREF="#gdTransparent">
gdTransparent</A> to indicate that the existing color should
be left unchanged for that particular pixel (allowing a dashed
line to be attractively drawn over an existing image).
<P>
Then, to draw a line using the style, use the normal
<A HREF="#gdImageLine">gdImageLine</A> function with the
special color value <A HREF="#gdStyled">gdStyled</A>.
<P>
As of <A HREF="#whatsnew1.1.1">version 1.1.1</A>, the style
array is copied when you set the style, so you need not
be concerned with keeping the array around indefinitely.
This should not break existing code that assumes styles
are not copied.
<P>
You can also combine styles and brushes to draw the brush
image at intervals instead of in a continuous stroke.
When creating a style for use with a brush, the
style values are interpreted differently: zero (0) indicates
pixels at which the brush should not be drawn, while one (1)
indicates pixels at which the brush should be drawn.
To draw a styled, brushed line, you must use the
special color value <A HREF="#gdStyledBrushed">
gdStyledBrushed</A>. For an example of this feature
in use, see gddemo.c (provided in the distribution).
<PRE>
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int styleDotted[2], styleDashed[6];
FILE *in;
int black;
int red;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* Set up dotted style. Leave every other pixel alone. */
styleDotted[0] = red;
styleDotted[1] = gdTransparent;
/* Set up dashed style. Three on, three off. */
styleDashed[0] = red;
styleDashed[1] = red;
styleDashed[2] = red;
styleDashed[3] = gdTransparent;
styleDashed[4] = gdTransparent;
styleDashed[5] = gdTransparent;
/* Set dotted style. Note that we have to specify how many pixels are
  in the style! */
gdImageSetStyle(im, styleDotted, 2);
/* Draw a line from the upper left corner to the lower right corner. */
<A HREF="#gdImageLine">gdImageLine</A>(im, 0, 0, 99, 99, <A HREF="#gdStyled">gdStyled</A>);
/* Now the dashed line. */
gdImageSetStyle(im, styleDashed, 6);
<A HREF="#gdImageLine">gdImageLine</A>(im, 0, 99, 0, 99, <A HREF="#gdStyled">gdStyled</A>);

/* ... Do something with the image, such as 
  saving it to a file ... */

/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageSetThickness">void gdImageSetThickness(gdImagePtr im, int thickness)</A> <STRONG>(FUNCTION)</STRONG>
<DD>gdImageSetThickness determines the width of lines drawn by the
<a href="#gdImageLine">gdImageLine</a>, <a href="#gdImagePolygon">gdImagePolygon</a>, <a href="#gdImageOpenPolygon">gdImageOpenPolygon</a>
and related functions, in pixels. 
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Set thickness. */
gdImageSetThickness(im, 4);
/* Draw a fat line from the upper left corner to the lower right corner. */
gdImageLine(im, 0, 0, 99, 99, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageAlphaBlending">void gdImageAlphaBlending(gdImagePtr im, int blending)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
The <a href="#gdImageAlphaBlending">gdImageAlphaBlending</a>
function allows for two different modes of drawing on truecolor
images. In blending mode, which is <strong>on by default (gd 2.0.2
and above)</strong>, the alpha channel component of the color 
supplied to all drawing functions, such as 
<a href="#gdImageSetPixel">gdImageSetPixel</a>, determines how much of 
the underlying color should be allowed to shine through. As a result, 
gd automatically blends the existing color at that point with the
drawing color, and stores the result in the image. The resulting pixel
is opaque. In non-blending mode, the drawing color is copied literally 
with its alpha channel information, replacing the destination pixel.
Blending mode is not available when drawing on palette images. 
<PRE>
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int red, blue;
im = <A HREF="#gdImageCreate">gdImageCreateTrueColor</A>(100, 100);
/* Background color */
red = <A HREF="#gdTrueColor">gdTrueColor</A>(255, 0, 0);  
gdImageFilledRectangle(im, 0, 0, 100, 100, red);
/* Drawing color. Full transparency would be an alpha channel value
  of 127 (gd has a 7 bit alpha chnanel). 0 is opaque,
  127 is transparent. So cut gdAlphaTransparent in half to get
  50% blending. */
blue = <A HREF="#gdTrueColor">gdTrueColorAlpha</A>(0, 0, 255, gdAlphaTransparent / 2);  
/* Draw with blending. Result will be 50% red, 50% blue: yellow 
  (emitted light, remember, not reflected light. What you learned 
  in Kindergarten is wrong here). */
gdImageAlphaBlending(im, 1);
<a href="#gdImageFilledRectangle">gdImageFilledRectangle</a>(im, 0, 0, 25, 25, blue);
/* Draw without blending. Result will be 50% blue, 50%
  the background color of the image viewer or web browser
  used; results in browsers that don't support
  semi-transparent pixels are unpredictable! */
gdImageAlphaBlending(im, 0);
<a href="#gdImageFilledRectangle">gdImageFilledRectangle</a>(im, 75, 75, 25, 25, blue);
/* Write the image to disk, etc. */
</pre>
<DT><A NAME="gdImageSaveAlpha">
void gdImageSaveAlpha(gdImagePtr im, int saveFlag)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
By default, gd 2.0.2 and above do not attempt to save full alpha channel information
(as opposed to single-color transparency) when saving PNG images. (PNG
is currently the only output format supported by gd which can accommodate
alpa channel information.) This saves space in the output file. If you wish
to create an image with alpha channel information for use with tools that
support it, call gdImageSaveAlpha(im, 1) to turn on saving of such 
information, and call <a href="#gdImageAlphaBlending">gdImageAlphaBlending(im, 0)</a>
to turn off alpha blending within the library so that alpha channel
information is actually stored in the image rather than being composited
immediately at the time that drawing functions are invoked.
<DT><A NAME="gdImageSetClip">
void gdImageSetClip(gdImagePtr im, int x1, int y1, int x2, int y2)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
Establishes a clipping rectangle. Once gdImageSetClip has been called,
all future drawing operations will remain within the specified clipping
area, until a new gdImageSetClip call takes place. For instance, 
if a clipping rectangle of 25, 25, 75, 75 has been set within a
100x100 image, a diagonal line from 0,0 to 99,99 will appear only 
between 25,25 and 75,75.
<p>
If gdImageSetClip is never called, the clipping area will be the
entire image. 
<p>
The parameters passed to gdImageSetClip are checked against the dimensions
of the image and limited to "safe" values.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Set the clipping rectangle. */
gdImageSetClip(im, 25, 25, 75, 75);
/* Draw a line from the upper left corner to the lower right corner. 
  Only the part within the clipping rectangle will appear. */
<a href="#gdImageLine">gdImageLine</a>(im, 0, 0, 99, 99, white);
/* ... Do something with the image, such as 
  saving it to a file ... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
See also <a href="#gdImageGetClip">gdImageGetClip</a>.
<DT><A NAME="gdImageGetClip">
void gdImageGetClip(gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
Fetches the boundaries of the current clipping rectangle.
<pre>
... Inside a function ... 
gdImagePtr im = <a href="#gdImageCreateTrueColor">gdImageCreateTrueColor</a>(100, 100);
int x1, y1, x2, y2;
gdImageSetClip(im, 25, 25, 75, 75);
gdImageGetClip(im, &x1, &y1, &x2, &y2);
printf("%d %d %d %d\n", x1, y1, x2, y2);
</pre>
The above code would print:
<pre>
25 25 75 75
</pre>
See also <a href="#gdImageSetClip">gdImageSetClip</a>.
</DL>
<H3><A NAME="query">Query Functions</A></H3>
<DL>
<DT><A NAME="gdImageBlue">
int gdImageAlpha(gdImagePtr im, int color)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageAlpha is a macro which returns the alpha channel component of
the specified color index. Alpha channel values vary between
0 (gdAlphaOpaque), which does not blend at all with the background,
through 127 (gdAlphaTransparent), which allows the background to
shine through 100%. Use this macro rather than accessing the
structure members directly.
int gdImageBlue(gdImagePtr im, int color)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageBlue is a macro which returns the blue component of
the specified color index. Use this macro rather than accessing the
structure members directly.
<DT><A NAME="gdImageGetPixel">int gdImageGetPixel(gdImagePtr im, int x, int y)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageGetPixel() retrieves the color index of a particular
pixel. Always use this function to query pixels;
do not access the pixels of the <A HREF="#gdImage">gdImage</A> structure
directly.
<PRE>
... inside a function ...
FILE *in;
gdImagePtr im;
int c;
in = fopen("mypng.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
c = gdImageGetPixel(im, gdImageSX(im) / 2, gdImageSY(im) / 2);
printf("The value of the center pixel is %d; RGB values are %d,%d,%d\n",
  c, im->red[c], im->green[c], im->blue[c]);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>  
<DT><A NAME="gdImageBoundsSafe">
int gdImageBoundsSafe(gdImagePtr im, int x, int y)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageBoundsSafe returns true (1) if the specified point is within the 
current clipping rectangle, false (0) if not. The clipping rectangle is
set by <a href="#gdImageSetClip">gdImageSetClip</a> and defaults
to the entire image. This function is intended primarily for
use by those who wish to add functions to gd. All of the gd drawing
functions already clip safely using this function or its macro
equivalent in gd.c, gdImageBoundsSafeMacro.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
if (gdImageBoundsSafe(im, 50, 50)) {
  printf("50, 50 is within the image bounds\n");
} else {
  printf("50, 50 is outside the image bounds\n");
}
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageGreen">
int gdImageGreen(gdImagePtr im, int color)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageGreen is a macro which returns the green component of
the specified color index. Use this macro rather than accessing the
structure members directly.
<DT><A NAME="gdImageRed">
int gdImageRed(gdImagePtr im, int color)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageRed is a macro which returns the red component of
the specified color index. Use this macro rather than accessing the
structure members directly.
<DT><A NAME="gdImageSX">
int gdImageSX(gdImagePtr im)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageSX is a macro which returns the width of the image
in pixels. Use this macro rather than accessing the
structure members directly.
<DT><A NAME="gdImageSY">
int gdImageSY(gdImagePtr im)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageSY is a macro which returns the height of the image
in pixels. Use this macro rather than accessing the
structure members directly.
</DL>
<H3><A NAME="fonts">Fonts and text-handling functions</A></H3>
<DL>
<DT><A NAME="gdFontGetSmall">
gdFontPtr gdFontGetSmall(void)</a>
<STRONG>(FUNCTION)</STRONG>
<DD>
Returns a font pointer for the "small" gd font. Your code must
include the header file <code>gdfonts.h</code> before
calling this function. Under Windows, due to the nature of DLLs, 
the use of this function is strongly recommended rather than attempting
to use the <code>gdFontSmall</code> pointer directly. (You may
safely assign the result to a local <code>gdFontPtr</code> variable
in your own code.)
<p>
See <a href="#gdImageString">gdImageString</a> for more information
and examples, or <a href="#gdImageStringFT">gdImageStringFT</a> for a
freetype-based alternative that supports truetype fonts.
<DT><A NAME="gdFontGetLarge">
gdFontPtr gdFontGetLarge(void)</a>
<STRONG>(FUNCTION)</STRONG>
<DD>
Returns a font pointer for the "large" gd font. Your code must
include the header file <code>gdfontl.h</code> before
calling this function. Under Windows, due to the nature of DLLs, 
the use of this function is strongly recommended rather than attempting
to use the <code>gdFontLarge</code> pointer directly. (You may
safely assign the result to a local <code>gdFontPtr</code> variable
in your own code.)
<p>
See <a href="#gdImageString">gdImageString</a> for more information
and examples, or <a href="#gdImageStringFT">gdImageStringFT</a> for a
freetype-based alternative that supports truetype fonts.
<DT><A NAME="gdFontGetMediumBold">
gdFontPtr gdFontGetMediumBold(void)</a>
<STRONG>(FUNCTION)</STRONG>
<DD>
Returns a font pointer for the "medium bold" gd font. Your code must
include the header file <code>gdfontmb.h</code> before
calling this function. Under Windows, due to the nature of DLLs, 
the use of this function is strongly recommended rather than attempting
to use the <code>gdFontMediumBold</code> pointer directly. (You may
safely assign the result to a local <code>gdFontPtr</code> variable
in your own code.)
<p>
See <a href="#gdImageString">gdImageString</a> for more information
and examples, or <a href="#gdImageStringFT">gdImageStringFT</a> for a
freetype-based alternative that supports truetype fonts.
<DT><A NAME="gdFontGetGiant">
gdFontPtr gdFontGetGiant(void)</a>
<STRONG>(FUNCTION)</STRONG>
<DD>
Returns a font pointer for the "giant" gd font. Your code must
include the header file <code>gdfontg.h</code> before
calling this function. Under Windows, due to the nature of DLLs, 
the use of this function is strongly recommended rather than attempting
to use the <code>gdFontGiant</code> pointer directly. (You may
safely assign the result to a local <code>gdFontPtr</code> variable
in your own code.)
<p>
See <a href="#gdImageString">gdImageString</a> for more information
and examples, or <a href="#gdImageStringFT">gdImageStringFT</a> for a
freetype-based alternative that supports truetype fonts.
<DT><A NAME="gdFontGetTiny">
gdFontPtr gdFontGetTiny(void)</a>
<STRONG>(FUNCTION)</STRONG>
<DD>
Returns a font pointer for the "tiny" gd font. Your code must
include the header file <code>gdfontt.h</code> before
calling this function. Under Windows, due to the nature of DLLs, 
the use of this function is strongly recommended rather than attempting
to use the <code>gdFontTiny</code> pointer directly. (You may
safely assign the result to a local <code>gdFontPtr</code> variable
in your own code.)
<p>
See <a href="#gdImageString">gdImageString</a> for more information
and examples, or <a href="#gdImageStringFT">gdImageStringFT</a> for a
freetype-based alternative that supports truetype fonts.
<DT><A NAME="gdImageChar">
void gdImageChar(gdImagePtr im, gdFontPtr font, int x, int y,
  int c, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageChar is used to draw single characters on the image.
(To draw multiple characters, use <A HREF="#gdImageString">
gdImageString</A> or <A HREF="#gdImageString16">
gdImageString16</A>.
See also <A HREF="#gdImageStringFT">gdImageStringFT</A> for a high quality
solution.)
The second argument is a pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. 
<p>
You must include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and (if you are not using a library-based approach) link with the
corresponding .c files to use the provided fonts.
<p>
<blockquote>
<b>Windows DLL users:</b> although you can use
these DLL-exported pointers directly, you cannot easily assign them to other 
pointers. This will cause hard-to-debug problems. To avoid such troubles, you 
should call the functions gdFontGetTiny(), gdFontGetSmall(), 
gdFontGetMediumBold(), gdFontGetLarge(), and gdFontGetGiant() in order to 
obtain pointers to the fonts under Windows.
</blockquote>
<p>
The character specified by the fifth
argument is drawn from left to right in the specified
color. (See <A HREF="#gdImageCharUp">gdImageCharUp</A> for a way
of drawing vertical text.) Pixels not
set by a particular character retain their previous color.
<PRE>
#include "gd.h"
#include "gdfontl.h"
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a character. */
gdImageChar(im, gdFontGetLarge(), 0, 0, 'Q', white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageCharUp">
void gdImageCharUp(gdImagePtr im, gdFontPtr font, int x, int y,
int c, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageCharUp is used to draw single characters on the image,
rotated 90 degrees.
(To draw multiple characters, use <A HREF="#gdImageStringUp">
gdImageStringUp</A> or <A HREF="#gdImageStringUp16">
gdImageStringUp16</A>.) The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and (if you are not using a library-based approach) link with the
corresponding .c files to use the provided fonts. 
<p>
<blockquote>
<b>Windows DLL users:</b> although you can use
these DLL-exported pointers directly, you cannot easily assign them to other 
pointers. This will cause hard-to-debug problems. To avoid such troubles, you 
should call the functions gdFontGetTiny(), gdFontGetSmall(), 
gdFontGetMediumBold(), gdFontGetLarge(), and gdFontGetGiant() in order to 
obtain pointers to the fonts under Windows.
</blockquote>
<p>
The character specified by
the fifth argument is drawn
from bottom to top, rotated at a 90-degree angle,  in the specified
color.  (See <A HREF="#gdImageChar">gdImageChar</A> for a way
of drawing horizontal text.)  Pixels not
set by a particular character retain their previous color.
<PRE>
#include "gd.h"
#include "gdfontl.h"
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a character upwards so it rests against the top of the image. */
gdImageCharUp(im, gdFontGetLarge(),
  0, gdFontGetLarge()->h, 'Q', white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageString">
void gdImageString(gdImagePtr im, gdFontPtr font, int x, int y,
unsigned char *s, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageString is used to draw multiple characters on the image.
(To draw single characters, use <A HREF="#gdImageChar">
gdImageChar</A>.) The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and (if you are not using a library-based approach) link with the
corresponding .c files to use the provided fonts.
<p>
<blockquote>
<b>Windows DLL users:</b> although you can use
these DLL-exported pointers directly, you cannot easily assign them to other 
pointers. This will cause hard-to-debug problems. To avoid such troubles, you 
should call the functions gdFontGetTiny(), gdFontGetSmall(), 
gdFontGetMediumBold(), gdFontGetLarge(), and gdFontGetGiant() in order to 
obtain pointers to the fonts under Windows.
</blockquote>
The null-terminated C string specified
by the fifth argument is drawn from left to right in the specified
color.  (See <A HREF="#gdImageStringUp">gdImageStringUp</A> for a way
of drawing vertical text.
See also <A HREF="#gdImageStringFT">gdImageStringFT</A> for a high
quality solution.)
Pixels not set by a particular character retain their previous color.
<PRE>
#include "gd.h"
#include "gdfontl.h"
#include &lt;string.h&gt;
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
/* String to draw. */
char *s = "Hello.";
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a centered string. */
gdImageString(im, gdFontGetLarge(),
  im->sx / 2 - (strlen(s) * gdFontGetLarge()->w / 2),
  im->sy / 2 - gdFontGetLarge()->h / 2,
  s, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageString16">
void gdImageString16(gdImagePtr im, gdFontPtr font, int x, int y,
unsigned short *s, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageString16 is used to draw multiple 16-bit characters on the image.
(To draw single characters, use <A HREF="#gdImageChar">
gdImageChar16</A>.) The second argument is a
pointer to a font definition structure; no 16-bit fonts are
provided with gd as standard equipment and there does not seem to be
much momentum to create them although the bdftogd script can do so. The 
preferred solution is <a href="#gdImageStringFT">gdImageStringFT</a>, which
uses freetype to provide truetype font support. 
<p>
<blockquote>
<b>Windows DLL users:</b> although you can use
these DLL-exported pointers directly, you cannot easily assign them to other 
pointers. This will cause hard-to-debug problems. To avoid such troubles, you 
should call the functions gdFontGetTiny(), gdFontGetSmall(), 
gdFontGetMediumBold(), gdFontGetLarge(), and gdFontGetGiant() in order to 
obtain pointers to the fonts under Windows.
</blockquote>
The null-terminated string of characters represented as 16-bit unsigned
short integers specified by the fifth argument is drawn from left to right
in the specified
color.  (See <A HREF="#gdImageStringUp16">gdImageStringUp16</A> for a way
of drawing vertical text.)  Pixels not
set by a particular character retain their previous color.
<p>
This function was added in gd1.3 to provide a means of rendering
fonts with more than 256 characters for those who have them. A
more frequently used routine is <a href="#gdImageString">gdImageString</a>.
<DT><A NAME="gdImageStringUp">
void gdImageStringUp(gdImagePtr im, gdFontPtr font, int x, int y,
unsigned char *s, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageStringUp is used to draw multiple characters on the image,
rotated 90 degrees.
(To draw single characters, use <A HREF="#gdImageCharUp">
gdImageCharUp</A>.) The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and (if you are not using a library-based approach) link with the
corresponding .c files to use the provided fonts.
<blockquote>
<b>Windows DLL users:</b> although you can use
these DLL-exported pointers directly, you cannot easily assign them to other 
pointers. This will cause hard-to-debug problems. To avoid such troubles, you 
should call the functions gdFontGetTiny(), gdFontGetSmall(), 
gdFontGetMediumBold(), gdFontGetLarge(), and gdFontGetGiant() in order to 
obtain pointers to the fonts under Windows.
</blockquote>

The null-terminated C string specified
by the fifth argument is drawn from bottom to top (rotated
90 degrees) in the specified color.  (See
<A HREF="#gdImageString">gdImageString</A> for a way
of drawing horizontal text.)  Pixels not
set by a particular character retain their previous color.
<PRE>
#include "gd.h"
#include "gdfontl.h"
#include &lt;string.h&gt;
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
/* String to draw. */
char *s = "Hello.";
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color white (red, green and blue all maximum). */
white = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 255, 255);  
/* Draw a centered string going upwards. Axes are reversed,
  and Y axis is decreasing as the string is drawn. */
gdImageStringUp(im, gdFontGetLarge(),
  im->w / 2 - gdFontGetLarge()->h / 2,
  im->h / 2 + (strlen(s) * gdFontGetLarge()->w / 2),
  s, white);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageStringUp16">
void gdImageStringUp16(gdImagePtr im, gdFontPtr font, int x, int y,
unsigned short *s, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageString is used to draw multiple 16-bit characters vertically on
the image. (To draw single characters, use <A HREF="#gdImageChar">
gdImageChar</A>.) The second argument is a
pointer to a font definition structure; five fonts are
provided with gd, gdFontTiny, gdFontSmall, gdFontMediumBold,
gdFontLarge, and gdFontGiant. You must
include the files "gdfontt.h", "gdfonts.h", "gdfontmb.h",
"gdfontl.h" and "gdfontg.h" respectively
and (if you are not using a library-based approach) link with the
corresponding .c files to use the provided fonts.
<blockquote>
<b>Windows DLL users:</b> although you can use
these DLL-exported pointers directly, you cannot easily assign them to other 
pointers. This will cause hard-to-debug problems. To avoid such troubles, you 
should call the functions gdFontGetTiny(), gdFontGetSmall(), 
gdFontGetMediumBold(), gdFontGetLarge(), and gdFontGetGiant() in order to 
obtain pointers to the fonts under Windows.
</blockquote>
The null-terminated string of characters represented as 16-bit unsigned
short integers specified by the fifth argument is drawn from bottom to top
in the specified color.
(See <A HREF="#gdImageStringUp16">gdImageStringUp16</A> for a way
of drawing horizontal text.)  Pixels not
set by a particular character retain their previous color.
<p>
This function was added in gd1.3 to provide a means of rendering
fonts with more than 256 characters for those who have them. A
more frequently used routine is <a href="#gdImageStringUp">gdImageStringUp</a>.
<DT><A NAME="gdFTUseFontConfig">int gdFTUseFontConfig(int flag)</a>
<STRONG>(FUNCTION)</STRONG>
<DD>
GD 2.0.29 introduced the ability to use 
<a target=_top href="http://freedesktop.org/software/fontconfig">fontconfig patterns</a>
rather than font file names as parameters to 
<a href="#gdImageStringFT">gdImageStringFT</a>,
<a href="#gdImageStringFTEx">gdImageStringFTEx</a> and
<a href="#gdImageStringFTEx">gdImageStringFTCircle</a>. 
For backwards compatibility reasons, the fontlist parameter to those
functions is still expected to be a full or partial font file path name 
or list thereof by default. However, as a convenience, a single call
to gdFTUseFontConfig with a nonzero parameter configures gd to expect
the fontlist parameter to be a fontconfig pattern. Regardless of whether
the flag argument is nonzero, this function returns true when the 
fontconfig library is available and false when it is not. When fontconfig
is not available, the fontlist parameter always behaves as in previous
versions of GD.
<pre>
#include "gd.h"
#include &lt;string.h&gt;
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
int brect[8];
int x, y;
char *err;

char *s = "Hello."; /* String to draw. */
double sz = 40.;
char *fc = "times:bold:italic"; /* fontconfig pattern */

/* Signal that all freetype font calls in this program will receive
  fontconfig patterns rather than filenames of font files */
gdUseFontConfig(1);

/* obtain brect so that we can size the image */
err = <A HREF="#gdImageStringFT">gdImageStringFT</A>(NULL,&brect[0],0,fc,sz,0.,0,0,s);
if (err) {fprintf(stderr,err); return 1;}

/* create an image big enough for the string plus a little whitespace */
x = brect[2]-brect[6] + 6;
y = brect[3]-brect[7] + 6;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(x,y);

/* Background color (first allocated) */
white = <A HREF="#gdImageColorResolve">gdImageColorResolve</A>(im, 255, 255, 255);
black = <A HREF="#gdImageColorResolve">gdImageColorResolve</A>(im, 0, 0, 0);

/* render the string, offset origin to center string*/
/* note that we use top-left coordinate for adjustment
 * since gd origin is in top-left with y increasing downwards. */
x = 3 - brect[6];
y = 3 - brect[7];
err = <A HREF="#gdImageStringFT">gdImageStringFT</A>(im,&brect[0],black,fc,sz,0.0,x,y,s);
if (err) {fprintf(stderr,err); return 1;}
</pre>
<DT><A NAME="gdImageStringFT">
char *gdImageStringFT(gdImagePtr im, int *brect,
  int fg, char *fontname, double ptsize, double angle,
  int x, int y, char *string)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
<strong>RECOMMENDED. New in 1.8.4.</strong> gdImageStringFT draws text using the
FreeType 2.x library.
<p>
gdImageStringFT draws a string of anti-aliased characters on the image using 
the <a target=_top HREF=http://www.freetype.org/>FreeType</A>
library to render user-supplied TrueType fonts. <strong>We do not provide 
TrueType fonts (.ttf and .ttc files). Obtaining them is entirely up to 
you.</strong> The string is anti-aliased, meaning that there should be 
fewer "jaggies" visible. The fontname is the full pathname to a TrueType 
font file, or a font face name if the GDFONTPATH environment variable
or the compiled-in DEFAULT_FONTPATH macro of gdft.c have been set intelligently. In the absence of a full path, the font face name may be presented with or without extension (2.0.26).
<p>
The null-terminated <b>string</b> argument is considered to be encoded via the UTF_8
standard; also, HTML entities are supported, including decimal,
hexadecimal, and named entities (2.0.26). Those who are passing 
ordinary ASCII strings may have difficulty with the &amp; 
character unless encoded correctly as &amp; but should have no 
other difficulties.
<p>
The string may be arbitrarily scaled (ptsize) and rotated (angle in radians).
The direction of rotation is counter-clockwise, with 0 radians (0 degrees)
at 3 o'clock and PI/2 radians (90 degrees) at 12 o'clock. 

<p>
The user-supplied int brect[8] array is filled on return from gdImageStringFT
with the 8 elements representing the 4 corner coordinates of the
bounding rectangle (the smallest rectangle that completely surrounds the 
rendered string and does not intersect any pixel of the rendered string).

<TABLE BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP">0</TD><TD ALIGN="LEFT" VALIGN="TOP">
lower left corner, X position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">1</TD><TD ALIGN="LEFT" VALIGN="TOP">
lower left corner, Y position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">2</TD><TD ALIGN="LEFT" VALIGN="TOP">
lower right corner, X position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">3</TD><TD ALIGN="LEFT" VALIGN="TOP">
lower right corner, Y position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">4</TD><TD ALIGN="LEFT" VALIGN="TOP">
upper right corner, X position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">5</TD><TD ALIGN="LEFT" VALIGN="TOP">
upper right corner, Y position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">6</TD><TD ALIGN="LEFT" VALIGN="TOP">
upper left corner, X position</TD></TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP">7</TD><TD ALIGN="LEFT" VALIGN="TOP">
upper left corner, Y position</TD></TR>
</TABLE>
<p>
The points are relative to the text regardless of the angle, so "upper left"
means in the top left-hand corner seeing the text horizontally.
<p>
Use a NULL gdImagePtr to get the bounding rectangle without rendering.
This is a relatively cheap operation if followed by a rendering of the same
string, because of the caching of the partial rendering during bounding
rectangle calculation.
<p>
The string is rendered in the color indicated by the gf color index.
<strong>Use the negative of the desired color index to 
disable anti-aliasing.</strong>
<p>
The string may contain UTF-8 sequences like: "&amp;#192;"
<p>
gdImageStringFT will return a null char* on success, or an error
string on failure.
<PRE>
#include "gd.h"
#include &lt;string.h&gt;
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int white;
int brect[8];
int x, y;
char *err;

char *s = "Hello."; /* String to draw. */
double sz = 40.;
char *f = "/usr/local/share/ttf/Times.ttf";  /* User supplied font */

/* obtain brect so that we can size the image */
err = <A HREF="#gdImageStringFT">gdImageStringFT</A>(NULL,&brect[0],0,f,sz,0.,0,0,s);
if (err) {fprintf(stderr,err); return 1;}

/* create an image big enough for the string plus a little whitespace */
x = brect[2]-brect[6] + 6;
y = brect[3]-brect[7] + 6;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(x,y);

/* Background color (first allocated) */
white = <A HREF="#gdImageColorResolve">gdImageColorResolve</A>(im, 255, 255, 255);
black = <A HREF="#gdImageColorResolve">gdImageColorResolve</A>(im, 0, 0, 0);

/* render the string, offset origin to center string*/
/* note that we use top-left coordinate for adjustment
 * since gd origin is in top-left with y increasing downwards. */
x = 3 - brect[6];
y = 3 - brect[7];
err = <A HREF="#gdImageStringFT">gdImageStringFT</A>(im,&brect[0],black,f,sz,0.0,x,y,s);
if (err) {fprintf(stderr,err); return 1;}

/* Write img to stdout */
<A HREF="#gdImagePng">gdImagePng</A>(im, stdout);

/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
See also <a href="#gdImageStringFTEx">gdImageStringFTEx</a>.
<DT><A NAME="gdImageStringFTEx">
char *gdImageStringFTEx(gdImagePtr im, int *brect,
  int fg, char *fontname, double ptsize, double angle,
  int x, int y, gdFTStringExtraPtr strex)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
<strong>New in 2.0.5,</strong> also found in common third-party versions
of gd. gdImageStringFTEx extends the capabilities of 
<a href="#gdImageStringFT">gdImageStringFT</a> by providing a 
way to pass additional parameters. 
<p>
If the <code>strex</code> parameter is not null, it must point to a
<code>gdFTStringExtra</code> structure. As of gd 2.0.5, this structure
is defined as follows:
<pre>
typedef struct {
       /* logical OR of gdFTEX_ values */
       int flags; 
       /* fine tune line spacing for '\n' */
       double linespacing; 
       /* Preferred character mapping */
       int charmap;
       /* Rendering resolution */
       int hdpi;
       int vdpi;
       char *xshow;
       char *fontpath;
} gdFTStringExtra, *gdFTStringExtraPtr;
</pre>
To output multiline text with a specific line spacing, 
include <code>gdFTEX_LINESPACE</code> in the setting of
<code>flags</code>:
<pre>
flags |= gdFTEX_LINESPACE;
</pre>
And also set <code>linespacing</code> to the desired spacing, expressed as a
multiple of the font height. Thus a line spacing of 1.0 is the
minimum to guarantee that lines of text do not collide.
<p>
If <code>gdFTEX_LINESPACE</code> is not present, or 
<code>strex</code> is null, or <a href="#gdImageStringFT">gdImageStringFT</a>
is called, <code>linespacing</code> defaults to 1.05.
<p>
To specify a preference for Unicode, Shift_JIS Big5 character encoding,
set or To output multiline text with a specific line spacing, 
include <code>gdFTEX_CHARMAP</code> in the setting of
<code>flags</code>:
<pre>
flags |= gdFTEX_CHARMAP;
</pre>
And set <code>charmap</code> to the desired value, which can be
any of gdFTEX_Unicode, gdFTEX_Shift_JIS, or gdFTEX_Big5. If you do not
specify a preference, Unicode will be tried first. If the preferred
character mapping is not found in the font, other character mappings 
are attempted.
<p>
GD operates on the assumption that the output image will be
rendered to a computer screen. By default, gd passes a
resolution of 96 dpi to the freetype text rendering engine. 
This influences the "hinting" decisions made by the renderer. To
specify a different resolution, set hdpi and vdpi accordingly
(in dots per inch) and add <code>gdFTEX_RESOLUTION</code> to <code>flags</code>:
<pre>
flags | gdFTEX_RESOLUTION;
</pre>
GD 2.0.29 and later will normally attempt to apply kerning tables, if 
fontconfig is available, to adjust the relative positions of consecutive 
characters more ideally for that pair of characters. This can be turn off by
specifying the gdFTEX_DISABLE_KERNING flag:
<pre>
flags | gdFTEX_DISABLE_KERNING;
</pre>
GD 2.0.29 and later can return a vector of individual character
position advances, occasionally useful in applications that must know
exactly where each character begins. This is returned in the xshow
element of the gdFTStringExtra structure if the gdFTEX_XSHOW
flag is set:
<pre>
flags | gdFTEX_XSHOW;
</pre>
<b>The caller is responsible for calling gdFree() on the xshow
element after the call</b> if gdFTEX_XSHOW is set.
<p>
GD 2.0.29 and later can also return the path to the actual font file
used if the gdFTEX_RETURNFONTPATHNAME flag is set. This is useful because 
GD 2.0.29 and above are capable of
selecting a font automatically based on a fontconfig font pattern
when fontconfig is available. This information is returned in the
fontpath element of the gdFTStringExtra structure. 
<pre>
flags | gdFTEX_RETURNFONTPATHNAME;
</pre>
<b>The caller is responsible for calling gdFree() on the fontpath
element after the call</b> if gdFTEX_RETURNFONTPATHNAME is set.
<p>
GD 2.0.29 and later can use fontconfig to resolve
font names, including fontconfig patterns, if the gdFTEX_FONTCONFIG
flag is set. As a convenience, this behavior can be made the default
by calling <a href="#gdFTUseFontConfig">gdFTUseFontConfig</a> with
a nonzero value. In that situation it is not necessary to set the
gdFTEX_FONTCONFIG flag on every call; however explicit font path names
can still be used if the gdFTEX_FONTPATHNAME flag is set:
<pre>
flags | gdFTEX_FONTPATHNAME;
</pre>
<p>
Unless <a href="#gdFTUseFontConfig">gdFTUseFontConfig</a> has been
called with a nonzero value, GD 2.0.29 and later will still expect
the fontlist argument to the freetype text output functions to be
a font file name or list thereof as in previous versions. If you do
not wish to make fontconfig the default, it is
still possible to force the use of fontconfig for a single call to
the freetype text output functions by setting the gdFTEX_FONTCONFIG
flag:
<pre>
flags | gdFTEX_FONTCONFIG;
</pre>
GD 2.0.29 and above can use fontconfig to resolve
font names, including fontconfig patterns, if the gdFTEX_FONTCONFIG
flag is set. As a convenience, this behavior can be made the default
by calling <a href="#gdFTUseFontConfig">gdFTUseFontConfig</a> with
a nonzero value. In that situation it is not necessary to set the
gdFTEX_FONTCONFIG flag on every call; however explicit font path names
can still be used if the gdFTEX_FONTPATHNAME flag is set:
<pre>
flags | gdFTEX_FONTPATHNAME;
</pre>
For more information, see <a href="#gdImageStringFT">gdImageStringFT</a>.
<DT><A NAME="gdImageStringFTCircle">
char *gdImageStringFTCircle(gdImagePtr im,
        int cx,
        int cy,
        double radius,
        double textRadius,
        double fillPortion,
        char *font,
        double points,
        char *top,
        char *bottom,
        int fgcolor)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
Draws the text strings specified by <code>top</code> and <code>bottom</code> 
on <code>im</code>, curved along the edge of a circle of radius 
<code>radius</code>, with its center at <code>cx</code> and <code>cy</code>. 
<code>top</code> is written clockwise
along the top; <code>bottom</code> is written counterclockwise
along the bottom. <code>textRadius</code> determines the "height"
of each character; if <code>textRadius</code> is 1/2 of 
<code>radius</code>,
characters extend halfway from the edge to the center.
<code>fillPortion</code> varies from 0 to 1.0, with useful values
from about 0.4 to 0.9, and determines how much of the
180 degrees of arc assigned to each section of text
is actually occupied by text; 0.9 looks better than
1.0 which is rather crowded. <code>font</code> is a freetype
font; see gdImageStringFT. <code>points</code> is passed to the
freetype engine and has an effect on hinting; although
the size of the text is determined by <code>radius</code>, 
<code>textRadius</code>, and <code>fillPortion</code>, you should 
pass a point size that
"hints" appropriately -- if you know the text will be
large, pass a large point size such as 24.0 to get the
best results. <code>fgcolor</code> can be any color, and may have
an alpha component, do blending, etc.
<p>
Returns 0 on success, or an error string otherwise.
<pre>
#include &lt;stdio.h&gt;
#include &lt;gd.h&gt;

int main (int argc, char *argv[])
{
        FILE *in;
        FILE *out;
        gdImagePtr im;
        int radius;
        /* Create an image of text on a circle, with an
                alpha channel so that we can copy it onto a
                background */
        in = fopen("mypicture.jpg", "rb");
        if (!in) {
                im = gdImageCreateTrueColor(300, 300);
        } else {
                im = gdImageCreateFromJpeg(in);
                fclose(in);
        }
        if (gdImageSX(im) &lt; gdImageSY(im)) {
                radius = gdImageSX(im) / 2;
        } else {
                radius = gdImageSY(im) / 2;
        }
        gdStringFTCircle(
                im,
                gdImageSX(im) / 2,
                gdImageSY(im) / 2,
                radius,
                radius / 2,
                0.8,
                "arial",
                24,
                "top text",
                "bottom text",
                gdTrueColorAlpha(240, 240, 255, 32));
        out = fopen("gdfx.png", "wb");
        if (!out) {
                fprintf(stderr, "Can't create gdfx.png\n");
                return 1;
        }
        gdImagePng(im, out);
        fclose(out);
        gdImageDestroy(im);
        return 0;
}
</pre>

<p>
For more information, see <a href="#gdImageStringFTEx">gdImageStringFTEx</a>
and <a href="#gdImageSquareToCircle">gdImageSquareToCircle</a>.
<DT><A NAME="gdImageStringTTF">
char *gdImageStringTTF(gdImagePtr im, int *brect,
  int fg, char *fontname, double ptsize, double angle,
  int x, int y, char *string)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
<strong>DEPRECATED.</strong> This function simply invokes
<a href="#gdImageStringFT">gdImageStringFT</a> for backwards
compatibility with old code that was written with FreeType 1.x.
<DT><A NAME="gdFontCacheSetup">
int gdFontCacheSetup(void)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
This function initializes the font cache for freetype text output
functions such as <a href="#gdImageStringFTEx">gdImageStringFTEx</a>.
If this function is not called by the programmer, it is invoked
automatically on the first truetype text output call, which is
perfectly safe <b>unless</b> the application is multithreaded.
Multithreaded applications should directly invoke this function before
allowing any thread to use freetype text output. Returns 0 on success,
nonzero if the freetype library fails to initialize.
<DT><A NAME="gdFontCacheShutdown">
void gdFontCacheShutdown(void)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
This function releases the memory used by the freetype font cache
and the text output mutex. Applications that use gd for their
entire lifetime, then exit, need not call this function.
</DL>
<H3><A NAME="colors">Color-handling functions</A></H3>
<DL>
<DT><A NAME="gdImageColorAllocate">
int gdImageColorAllocate(gdImagePtr im, int r, int g, int b)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorAllocate finds the first available color index in
the image specified, sets its RGB values to those requested
(255 is the maximum for each),
and returns the index of the new color table entry, or an RGBA
value in the case of a truecolor image; in either case you can
then use the returned value as a parameter to drawing functions. When
creating a new palette-based image, the first time you invoke this function,
you are setting the background color for that image. 
<P>
In the event that all <A HREF="#gdMaxColors">gdMaxColors</A> colors
(256) have already been allocated, gdImageColorAllocate will
return -1 to indicate failure. (This is not uncommon when
working with existing PNG files that already use 256 colors.)
Note that gdImageColorAllocate
does not check for existing colors that match your request;
see <A HREF="#gdImageColorExact">gdImageColorExact</A>,
<A HREF="#gdImageColorClosest">gdImageColorClosest</A> and
<A HREF="#gdImageColorClosestHWB">gdImageColorClosestHWB</A>
for ways to locate existing colors that approximate the
color desired in situations where a new color is not available.
Also see <A HREF="#gdImageColorResolve">gdImageColorResolve</A>,
new in gd-1.6.2.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int red;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color red. */
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* Draw a dashed line from the upper left corner 
  to the lower right corner. */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as saving 
  it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorAllocateAlpha">
int gdImageColorAllocateAlpha(gdImagePtr im, int r, int g, int b, int a)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorAllocateAlpha finds the first available color index in
the image specified, sets its RGBA values to those requested
(255 is the maximum for red, green and blue, and 127 represents
full transparency for alpha),
and returns the index of the new color table entry, or an RGBA
value in the case of a truecolor image; in either case you can
then use the returned value as a parameter to drawing functions. When
creating a new palette-based image, the first time you invoke this function,
you are setting the background color for that image. 
<P>
In the event that all <A HREF="#gdMaxColors">gdMaxColors</A> colors
(256) have already been allocated, gdImageColorAllocate will
return -1 to indicate failure. (This is not uncommon when
working with existing palette-based PNG files that already use 256 colors.)
Note that gdImageColorAllocateAlpha
does not check for existing colors that match your request;
see <A HREF="#gdImageColorExactAlpha">gdImageColorExactAlpha</A> and
<A HREF="#gdImageColorClosestAlpha">gdImageColorClosestAlpha</A>
for ways to locate existing colors that approximate the
color desired in situations where a new color is not available.
Also see <A HREF="#gdImageColorResolveAlpha">gdImageColorResolveAlpha</A>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
int red;
im = <A HREF="#gdImageCreate">gdImageCreate</A>(100, 100);
/* Background color (first allocated) */
black = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 0, 0, 0);  
/* Allocate the color red, 50% transparent. */
red = <A HREF="#gdImageColorAllocateAlpha">gdImageColorAllocateAlpha</A>(im, 255, 0, 0, 64);  
/* Draw a dashed line from the upper left corner to the lower right corner. */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorClosest">
int gdImageColorClosest(gdImagePtr im, int r, int g, int b)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorClosest searches the colors which have been
defined thus far in the image specified and returns the
index of the color with RGB values closest to those of the
request. (Closeness is determined by Euclidian distance,
which is used to determine the distance in three-dimensional color
space between colors.)
<P>
If no colors have yet been allocated in the image,
gdImageColorClosest returns -1.
<p>
When applied to a truecolor image, this function always
succeeds in returning the desired color.
<P>
This function is most useful as a backup method for choosing
a drawing color when an image already contains
<A HREF="#gdMaxColors">gdMaxColors</A> (256) colors and
no more can be allocated. (This is not uncommon when
working with existing PNG files that already use many colors.)
See <A HREF="#gdImageColorExact">gdImageColorExact</A>
for a method of locating exact matches only.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
int red;
/* Let's suppose that photo.png is a scanned photograph with
  many colors. */
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Try to allocate red directly */
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* If we fail to allocate red... */
if (red == (-1)) {
  /* Find the <em>closest</em> color instead. */
  red = gdImageColorClosest(im, 255, 0, 0);
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorClosestAlpha">
int gdImageColorClosestAlpha(gdImagePtr im, int r, int g, int b, int a)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorClosest searches the colors which have been
defined thus far in the image specified and returns the
index of the color with RGBA values closest to those of the
request. (Closeness is determined by Euclidian distance,
which is used to determine the distance in four-dimensional color/alpha
space between colors.)
<P>
If no colors have yet been allocated in the image,
gdImageColorClosestAlpha returns -1.
<p>
When applied to a truecolor image, this function always
succeeds in returning the desired color.
<P>
This function is most useful as a backup method for choosing
a drawing color when a palette-based image already contains
<A HREF="#gdMaxColors">gdMaxColors</A> (256) colors and
no more can be allocated. (This is not uncommon when
working with existing palette-based PNG files that already use many colors.)
See <A HREF="#gdImageColorExactAlpha">gdImageColorExactAlpha</A>
for a method of locating exact matches only.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
int red;
/* Let's suppose that photo.png is a scanned photograph with
  many colors. */
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Try to allocate red, 50% transparent, directly */
red = <A HREF="#gdImageColorAllocateAlpha">gdImageColorAllocateAlpha</A>(im, 255, 0, 0, 64);  
/* If we fail to allocate red... */
if (red == (-1)) {
  /* Find the <em>closest</em> color instead. */
  red = gdImageColorClosestAlpha(im, 255, 0, 0, 64);
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorClosestHWB">
int gdImageColorClosestHWB(gdImagePtr im, int r, int g, int b)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorClosestHWB searches the colors which have been
defined thus far in the image specified and returns the
index of the color with hue, whiteness and blackness closest to the
requested color. This scheme is typically superior to the 
Euclidian distance scheme used by 
<a href="#gdImageColorClosest">gdImageColorClosest</a>.
<P>
If no colors have yet been allocated in the image,
gdImageColorClosestHWB returns -1.
<p>
When applied to a truecolor image, this function always
succeeds in returning the desired color.
<P>
This function is most useful as a backup method for choosing
a drawing color when an image already contains
<A HREF="#gdMaxColors">gdMaxColors</A> (256) colors and
no more can be allocated. (This is not uncommon when
working with existing PNG files that already use many colors.)
See <A HREF="#gdImageColorExact">gdImageColorExact</A>
for a method of locating exact matches only.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
FILE *in;
int red;
/* Let's suppose that photo.png is a scanned photograph with
  many colors. */
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Try to allocate red directly */
red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
/* If we fail to allocate red... */
if (red == (-1)) {
  /* Find the <em>closest</em> color instead. */
  red = gdImageColorClosestHWB(im, 255, 0, 0);
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorExact">
int gdImageColorExact(gdImagePtr im, int r, int g, int b)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorExact searches the colors which have been
defined thus far in the image specified and returns the
index of the first color with RGB values which exactly
match those of the request. If no allocated color matches the
request precisely, gdImageColorExact returns -1.
See <A HREF="#gdImageColorClosest">gdImageColorClosest</A>
for a way to find the color closest to the color requested.
<p>
When applied to a truecolor image, this function always
succeeds in returning the desired color.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int red;
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* The image may already contain red; if it does, we'll save a slot
  in the color table by using that color. */
/* Try to allocate red directly */
red = gdImageColorExact(im, 255, 0, 0);
/* If red isn't already present... */
if (red == (-1)) {
  /* Second best: try to allocate it directly. */
  red = <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>(im, 255, 0, 0);  
  /* Out of colors, so find the <em>closest</em> color instead. */
  red = gdImageColorClosest(im, 255, 0, 0);
}
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorResolve">
int gdImageColorResolve(gdImagePtr im, int r, int g, int b)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorResolve searches the colors which have been
defined thus far in the image specified and returns the
index of the first color with RGB values which exactly
match those of the request. If no allocated color matches the
request precisely, then gdImageColorResolve tries to allocate the
exact color.  If there is no space left in the color table then
gdImageColorResolve returns the closest color (as in gdImageColorClosest).
This function always returns an index of a color.
<p>
When applied to a truecolor image, this function always
succeeds in returning the desired color.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int red;
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* The image may already contain red; if it does, we'll save a slot
  in the color table by using that color. */
/* Get index of red, or color closest to red */
red = gdImageColorResolve(im, 255, 0, 0);
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorResolveAlpha">
int gdImageColorResolveAlpha(gdImagePtr im, int r, int g, int b, int a)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorResolveAlpha searches the colors which have been
defined thus far in the image specified and returns the
index of the first color with RGBA values which exactly
match those of the request. If no allocated color matches the
request precisely, then gdImageColorResolveAlpha tries to allocate the
exact color. If there is no space left in the color table then
gdImageColorResolveAlpha returns the closest color (as in gdImageColorClosestAlpha).
This function always returns an index of a color.
<p>
When applied to a truecolor image, this function always
succeeds in returning the desired color.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int red;
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* The image may already contain red; if it does, 
  we'll save a slot in the color table by using that color. */
/* Get index of red, 50% transparent, or the next best thing */
red = gdImageColorResolveAlpha(im, 255, 0, 0, 64);
/* Draw a dashed line from the upper left corner to the lower right corner */
gdImageDashedLine(im, 0, 0, 99, 99, red);
/* ... Do something with the image, such as saving 
  it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorsTotal">
int gdImageColorsTotal(gdImagePtr im)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageColorsTotal is a macro which returns the number of
colors currently allocated in a palette image. For truecolor
images, the result of this call is undefined and should not
be used.
<DT><A NAME="gdImageRed">
int gdImageRed(gdImagePtr im, int c)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageRed is a macro which returns the red portion
of the specified color in the image. This macro works
for both palette and truecolor images.
<DT><A NAME="gdImageGreen">
int gdImageGreen(gdImagePtr im, int c)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageGreen is a macro which returns the green portion
of the specified color in the image.  This macro works
for both palette and truecolor images.
<DT><A NAME="gdImageBlue">
int gdImageBlue(gdImagePtr im, int c)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageBlue is a macro which returns the blue portion
of the specified color in the image.  This macro works
for both palette and truecolor images.
<DT><A NAME="gdImageGetInterlaced">
int gdImageGetInterlaced(gdImagePtr im)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageGetInterlaced is a macro which returns true (1)
if the image is interlaced, false (0) if not.
Use this macro to obtain this information; do not
access the structure directly.
See <A HREF="#gdImageInterlace">gdImageInterlace</A> for
a means of interlacing images.
<DT><A NAME="gdImageGetTransparent">
int gdImageGetTransparent(gdImagePtr im)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageGetTransparent is a macro which returns the
current transparent color index in the image.
If there is no transparent color, gdImageGetTransparent
returns -1. Use this macro to obtain this information; do not
access the structure directly.
<DT><A NAME="gdImageColorDeallocate">
void gdImageColorDeallocate(gdImagePtr im, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorDeallocate marks the specified color as being
available for reuse. It does not attempt to determine whether
the color index is still in use in the image. After a call
to this function, the next call to
<A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>
for the same image will set new RGB values for that
color index, changing the color of any pixels which
have that index as a result. If multiple calls to
gdImageColorDeallocate are made consecutively, the lowest-numbered
index among them will be reused by the next
<A HREF="#gdImageColorAllocate"> gdImageColorAllocate</A> call.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int red, blue;
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Look for red in the color table. */
red = gdImageColorExact(im, 255, 0, 0);
/* If red is present... */
if (red != (-1)) {
  /* Deallocate it. */
  gdImageColorDeallocate(im, red);
  /* Allocate blue, reusing slot in table.
    Existing red pixels will change color. */
  blue = gdImageColorAllocate(im, 0, 0, 255);
}
/* ... Do something with the image, such as 
  saving it to a file... */
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageColorTransparent">
void gdImageColorTransparent(gdImagePtr im, int color)</A>
<STRONG>(FUNCTION)</STRONG>
<DD>
gdImageColorTransparent sets the transparent color index
for the specified image to the specified index. To indicate
that there should be <em>no</em> transparent color, invoke
gdImageColorTransparent with a color index of -1.  Note that
JPEG images do not support transparency, so this setting has no effect
when writing JPEG images.
<P>
The color index used should be an index
allocated by <A HREF="#gdImageColorAllocate">gdImageColorAllocate</A>,
whether explicitly invoked by your code or implicitly
invoked by loading an image.
In order to ensure that your image has a reasonable appearance
when viewed by users who do not have transparent background
capabilities (or when you are writing a JPEG-format file, which does
not support transparency), be sure to give reasonable RGB values to the
color you allocate for use as a transparent color,
<em>even though it will be transparent on systems
that support PNG transparency</em>.
<PRE>
... inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im;
int black;
FILE *in, *out;
in = fopen("photo.png", "rb");
im = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Look for black in the color table and make it transparent. */
black = <A HREF="#gdImageColorExact">gdImageColorExact</A>(im, 0, 0, 0);
/* If black is present... */
if (black != (-1)) {
  /* Make it transparent */
  gdImageColorTransparent(im, black);
}
/* Save the newly-transparent image back to the file */
out = fopen("photo.png", "wb");
<A HREF="#gdImagePng">gdImagePng</A>(im, out);
fclose(out);
/* Destroy it */
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdImageTrueColor">
void gdImageTrueColor(int red, int green, int blue)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdImageTrueColor returns an RGBA color value for use when
drawing on a truecolor image. Red, green, and blue are all
in the range between 0 (off) and 255 (maximum). This macro should 
not be used with palette-based images. If you need to write
code which is compatible with both palette-based and
truecolor images, use <a href="#gdImageColorResolve">gdImageColorResolve</a>.
<DT><A NAME="gdTrueColorAlpha">
void gdTrueColorAlpha(int red, int green, int blue, int alpha)</A>
<STRONG>(MACRO)</STRONG>
<DD>
gdTrueColorAlpha returns an RGBA color value for use when
drawing on a truecolor image with alpha channel transparency. Red, 
green, and blue are all
in the range between 0 (off) and 255 (maximum). Alpha is in the
range between 0 (opaque) and 127 (fully transparent). This macro should 
not be used with palette-based images. If you need to write
code which is compatible with both palette-based and
truecolor images, use <a href="#gdImageColorResolveAlpha">gdImageColorResolveAlpha</a>.</DL>
<H3><A NAME="copying">Copying and resizing functions</A></H3>
<DL>

<DT><A NAME="gdImageCopy">void gdImageCopy(gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCopy is used to copy a rectangular portion of one image to
another image. (For a way of stretching or shrinking the image
in the process, see <A HREF="#gdImageCopyResized">
gdImageCopyResized</A>.)
<P>
The <code>dst</code> argument is the destination image to which the
region will be copied. The <code>src</code> argument is the source
image from which the region is copied. The <code>dstX</code>
and <code>dstY</code> arguments specify the point in the destination
image to which the region will be copied. The <code>srcX</code>
and <code>srcY</code> arguments specify the upper left corner
of the region in the source image. The <code>w</code>
and <code>h</code> arguments specify the width and height
of the region.
<P>
When you copy a region from one location in an image to another
location in the same image, gdImageCopy will perform as expected
unless the regions overlap, in which case the result is
unpredictable.
<P>
<strong>Important note on copying between images:</strong> since
different images do
not necessarily have the same color tables, pixels are not simply set to the
same color index values to copy them. gdImageCopy will attempt
to find an identical RGB value in the destination image for
each pixel in the copied portion of the source image by
invoking <A HREF="#gdImageColorExact">gdImageColorExact</A>. If
such a value is not found, gdImageCopy will attempt to
allocate colors as needed using <A HREF="#gdImageColorAllocate">
gdImageColorAllocate</A>. If both of these methods fail,
gdImageCopy will invoke <A HREF="#gdImageColorClosest">
gdImageColorClosest</A> to find the color in the destination
image which most closely approximates the color of the
pixel being copied.
<PRE>
... Inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im_in;
<A HREF="#gdImagePtr">gdImagePtr</A> im_out;
int x, y;
FILE *in;
FILE *out;
/* Load a small png to tile the larger one with */
in = fopen("small.png", "rb");
im_in = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Make the output image four times as large on both axes */
im_out = <A HREF="#gdImageCreate">gdImageCreate</A>(im_in->sx * 4, im_in->sy * 4);
/* Now tile the larger image using the smaller one */
for (y = 0; (y < 4); y++) {
  for (x = 0; (x < 4); x++) {
    gdImageCopy(im_out, im_in,
      x * im_in->sx, y * im_in->sy,
      0, 0,
      im_in->sx, im_in->sy);
  }
}
out = fopen("tiled.png", "wb");
<A HREF="#gdImagePng">gdImagePng</A>(im_out, out);
fclose(out);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_in);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_out);
</PRE>
<DT><A NAME="gdImageCopyResized">void gdImageCopyResized(gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int destW, int destH, int srcW, int srcH)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCopyResized is used to copy a rectangular portion of one image to
another image. The X and Y dimensions of the original region and the
destination region can vary, resulting in stretching or shrinking of
the region as appropriate. (For a simpler version of this function
which does not deal with resizing, see <A HREF="#gdImageCopy">
gdImageCopy</A>.)
<P>
The <code>dst</code> argument is the destination image to which the
region will be copied. The <code>src</code> argument is the source
image from which the region is copied. The <code>dstX</code>
and <code>dstY</code> arguments specify the point in the destination
image to which the region will be copied. The <code>srcX</code>
and <code>srcY</code> arguments specify the upper left corner
of the region in the source image. The <code>dstW</code>
and <code>dstH</code> arguments specify the width and height
of the destination region. The <code>srcW</code>
and <code>srcH</code> arguments specify the width and height
of the source region and can differ from the destination size,
allowing a region to be scaled during the copying process.
<P>
When you copy a region from one location in an image to another
location in the same image, gdImageCopy will perform as expected
unless the regions overlap, in which case the result is
unpredictable. If this presents a problem, create a scratch image
in which to keep intermediate results.
<P>
<strong>Important note on copying between images:</strong> since images
do not necessarily have the same color tables, pixels are not simply set
to the same color index values to copy them. gdImageCopy will attempt
to find an identical RGB value in the destination image for
each pixel in the copied portion of the source image by
invoking <A HREF="#gdImageColorExact">gdImageColorExact</A>. If
such a value is not found, gdImageCopy will attempt to
allocate colors as needed using <A HREF="#gdImageColorAllocate">
gdImageColorAllocate</A>. If both of these methods fail,
gdImageCopy will invoke <A HREF="#gdImageColorClosest">
gdImageColorClosest</A> to find the color in the destination
image which most closely approximates the color of the
pixel being copied.
<PRE>
... Inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im_in;
<A HREF="#gdImagePtr">gdImagePtr</A> im_out;
int x, y;
FILE *in;
FILE *out;
/* Load a small png to expand in the larger one */
in = fopen("small.png", "rb");
im_in = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Make the output image four times as large on both axes */
im_out = <A HREF="#gdImageCreate">gdImageCreate</A>(im_in->sx * 4, im_in->sy * 4);
/* Now copy the smaller image, but four times larger */
gdImageCopyResized(im_out, im_in, 0, 0, 0, 0,
  im_out->sx, im_out->sy,
  im_in->sx, im_in->sy);  
out = fopen("large.png", "wb");
<A HREF="#gdImagePng">gdImagePng</A>(im_out, out);
fclose(out);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_in);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_out);
</PRE>
<DT><A NAME="gdImageCopyResampled">void gdImageCopyResampled(gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int destW, int destH, int srcW, int srcH)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCopyResampled is used to copy a rectangular portion of one image to
another image, smoothly interpolating pixel values so that, in particular,
reducing the size of an image still retains a great deal of clarity. The 
X and Y dimensions of the original region and the
destination region can vary, resulting in stretching or shrinking of
the region as appropriate. (For a simpler version of this function
which does not deal with resizing, see <A HREF="#gdImageCopy">
gdImageCopy</A>. For a version which does not interpolate pixel values,
see <A HREF="#gdImageCopyResized">gdImageCopyResized</A>.
<p>
Pixel values are only interpolated if the destination image is a
truecolor image. Otherwise, 
<a href="#gdImageCopyResized">gdImageCopyResized</a> is 
automatically invoked.
<P>
The <code>dst</code> argument is the destination image to which the
region will be copied. The <code>src</code> argument is the source
image from which the region is copied. The <code>dstX</code>
and <code>dstY</code> arguments specify the point in the destination
image to which the region will be copied. The <code>srcX</code>
and <code>srcY</code> arguments specify the upper left corner
of the region in the source image. The <code>dstW</code>
and <code>dstH</code> arguments specify the width and height
of the destination region. The <code>srcW</code>
and <code>srcH</code> arguments specify the width and height
of the source region and can differ from the destination size,
allowing a region to be scaled during the copying process.
<P>
When you copy a region from one location in an image to another
location in the same image, gdImageCopy will perform as expected
unless the regions overlap, in which case the result is
unpredictable. If this presents a problem, create a scratch image
in which to keep intermediate results.
<P>
<strong>Important note on copying between images:</strong> since images
do not necessarily have the same color tables, pixels are not simply set
to the same color index values to copy them. If the destination image
is a palette image, gd will use the 
<a href="#gdImageColorResolve">gdImageColorResolve</a> function to
determine the best color available.
<PRE>
... Inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im_in;
<A HREF="#gdImagePtr">gdImagePtr</A> im_out;
int x, y;
FILE *in;
FILE *out;
/* Load a large png to shrink in the smaller one */
in = fopen("large.png", "rb");
im_in = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Make the output image four times as small on both axes. Use
  a true color image so that we can interpolate colors. */
im_out = <A HREF="#gdImageCreate">gdImageCreateTrueColor</A>(im_in->sx / 4, im_in->sy / 4);
/* Now copy the large image, but four times smaller */
gdImageCopyResampled(im_out, im_in, 0, 0, 0, 0,
  im_out->sx, im_out->sy,
  im_in->sx, im_in->sy);  
out = fopen("large.png", "wb");
<A HREF="#gdImagePng">gdImagePng</A>(im_out, out);
fclose(out);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_in);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_out);
</PRE>
<DT><A NAME="gdImageCopyRotated">void gdImageCopyRotated(gdImagePtr dst, gdImagePtr src, double dstX, double dstY, int srcX, int srcY, int srcW, int srcH, int angle)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCopyRotated is used to copy a rectangular portion of one image to
another image, or to another region of the same image. <strong>The srcX and
srcY coordinates specify the upper left corner of the source area; however,
the dstX and dstY coordinates specify the CENTER of the destination area.
</strong> This important distinction is made because the rotated rectangle may
may or may not be parallel to the X and Y axes. The destination coordinates
may be floating point, as the center of the desired destination area may lie
at the center of a pixel (0.5 pixels) rather than its upper left corner.
The angle specified is an integer number of degrees, between 0 and 360,
with 0 degrees causing no change, and counterclockwise rotation as 
the angle increases.
<P>
When you copy a region from one location in an image to another
location in the same image, gdImageCopyRotated will perform as expected
unless the regions overlap, in which case the result is
unpredictable. If this presents a problem, create a scratch image
in which to keep intermediate results.
<P>
<strong>Important note on copying between images:</strong> since 
palette-based images do not necessarily have the same color tables, pixels 
are not simply set to the same color index values to copy them. 
If the destination image is not a truecolor image, 
<a href="#gdImageColorResolveAlpha">gdImageColorResolveAlpha</a> is 
used to choose the destination pixel.
<PRE>
... Inside a function ...
<A HREF="#gdImagePtr">gdImagePtr</A> im_in;
<A HREF="#gdImagePtr">gdImagePtr</A> im_out;
int x, y;
int a;
FILE *in;
FILE *out;
/* Load a small png to rotate in the larger one */
in = fopen("small.png", "rb");
im_in = <A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A>(in);
fclose(in);
/* Make the output image four times as large on both axes */
im_out = <A HREF="#gdImageCreate">gdImageCreate</A>(im_in->sx * 4, im_in->sy * 4);
/* Now rotate the smaller image */
for (a = 0; (a < 360); a += 45) {
        double x = cos(a * .0174532925) * gdImageSX(im_out) / 2;
        double y = -sin(a * .0174532925) * gdImageSY(im_out) / 2;
  gdImageCopyRotated(im_out, im_in, 
                gdImageSX(im_out) / 2 + x, 
                gdImageSY(im_out) / 2 + y, 
    0, 0,
                gdImageSX(im_in),
                gdImageSY(im_in),
                a); 
}
out = fopen("large.png", "wb");
<A HREF="#gdImagePng">gdImagePng</A>(im_out, out);
fclose(out);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_in);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im_out);
</PRE>

<DT><A NAME="gdImageCopyMerge">void gdImageCopyMerge(gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCopyMerge is almost identical to <a href=#gdImageCopy>gdImageCopy</a>, except that
it 'merges' the two images by an amount specified in the last parameter. If the last
parameter is 100, then it will function identically to gdImageCopy - the source image replaces
the pixels in the destination.
<p>
If, however, the <strong>pct</strong> parameter is less than 100, then the two images are merged.
With pct = 0, no action is taken.
<p>This feature is most useful to 'highlight' sections of an image by merging a solid color with
pct = 50:
<PRE>
... Inside a function ...
gdImageCopyMerge(im_out, im_in, 100, 200, 0, 0, 30, 50, 50);
</PRE>

<DT><A NAME="gdImageCopyMergeGray">void gdImageCopyMergeGray(gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int
 w, int h, int pct)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCopyMergeGray is almost identical to <a href=#gdImageCopyMerge>gdImageCopyMerge</a>,
except that when merging images it preserves the hue of the source by converting the destination
pixels to grey scale before the copy operation.
<PRE>
... Inside a function ...
gdImageCopyMergeGray(im_out, im_in, 100, 200, 0, 0, 30, 50, 50);
</PRE>

<DT><A NAME="gdImagePaletteCopy">void gdImagePaletteCopy(gdImagePtr dst, gdImagePtr src)
<STRONG> (FUNCTION)</STRONG>
<DD>
Copies a palette from one image to another, attempting to match the colors in the target image
to the colors
in the source palette.
<DT><A NAME="gdImageSquareToCircle">void gdImageSquareToCircle(gdImagePtr im, int radius)</a>
<STRONG> (FUNCTION)</STRONG>
<DD>
<b>im MUST be square, but can have any size.</b> Returns a new image
of width and height radius * 2, in which the X axis of
the original has been remapped to theta (angle) and the Y axis
of the original has been remapped to rho (distance from center).
This is known as a "polar coordinate transform."
See also <a href="#gdImageStringFTCircle">gdImageStringFTCircle</a>, which
uses this function internally.
<DT><A NAME="gdImageSharpen">void gdImageSharpen(gdImagePtr im, int pct)</a>
<STRONG> (FUNCTION)</STRONG>
<DD>
Sharpens the specified image. pct is a sharpening percentage, and
can be greater than 100. Silently does nothing to non-truecolor images.
Silently does nothing for pct<0. Transparency/alpha channel are not
altered.    
</DL>
<H3><A NAME="misc">Miscellaneous Functions</A></H3>
<DL>

<DT><A NAME="gdImageCompare">int gdImageCompare(gdImagePtr im1, gdImagePtr im2)
<STRONG> (FUNCTION)</STRONG>
<DD>
gdImageCompare returns a bitmap indicating if the two images are different. The members of the 
bitmap are defined in gd.h, but the most important is GD_CMP_IMAGE, which indicated that the images
will actually appear different when displayed. Other, less important, differences relate to pallette
entries. Any difference in the transparent colour is assumed to make images display differently,
even if the transparent colour is not used.
<PRE>
... Inside a function ...
cmpMask = gdImageCompare(im1, im2);
</PRE>

<DT><A NAME="gdImageInterlace">gdImageInterlace(gdImagePtr im, int interlace)</A> <strong>(FUNCTION)</strong>
<DD>
gdImageInterlace is used to determine whether an image should be stored
in a linear fashion, in which lines will appear on the display from
first to last, or in an interlaced fashion, in which the image
will "fade in" over several passes. By default, images are not
interlaced.  (When writing JPEG images, interlacing implies generating
progressive JPEG files, which are represented as a series of scans of
increasing quality.  Noninterlaced gd images result in regular
[sequential] JPEG data streams.)
<P>
A nonzero value for the interlace argument turns on interlace;
a zero value turns it off. Note that interlace has no effect
on other functions, and has no meaning unless you save the
image in PNG or JPEG format; the gd and xbm formats do not support
interlace.
<P>
When a PNG is loaded with
<A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A> or a JPEG is
loaded with
<A HREF="#gdImageCreateFromJpeg">gdImageCreateFromJpeg</A>, interlace
will be set according to the setting in the PNG or JPEG file.
<P>
Note that many PNG and JPEG viewers and web browsers do <em>not</em>
support interlace or the incremental display of progressive
JPEGs. However, the interlaced PNG or progressive JPEG should still
display; it will simply appear all at once, just as other images do.
<PRE>
gdImagePtr im;
FILE *out;
/* ... Create or load the image... */

/* Now turn on interlace */
gdImageInterlace(im, 1);
/* And open an output file */
out = fopen("test.png", "wb");
/* And save the image  -- could also use <A HREF="#gdImageJpeg">gdImageJpeg</A> */
<A HREF="#gdImagePng">gdImagePng</A>(im, out);
fclose(out);
<A HREF="#gdImageDestroy">gdImageDestroy</A>(im);
</PRE>
<DT><A NAME="gdFree">gdFree(void *ptr)</A> <strong>(FUNCTION)</strong>
<DD>
gdFree provides a reliable way to free memory allocated by functions
such as <a href="#gdImagePngPtr">gdImagePngPtr</a> which return
blocks of memory. Use of this function guarantees that the
version of <code>free()</code> that is ultimately called will
be intended for use with the version of <code>malloc()</code> that
originally allocated the block. 
</DL>
<H3><A NAME="constants">Constants</A></H3>
<DL>
<DT><A NAME="gdAntiAliased">gdAntiAliased</A> <strong>(CONSTANT)</strong>
<DD>
Used in place of a color when invoking a line-drawing
function such as <A HREF="#gdImageLine">gdImageLine</A>
or <A HREF="#gdImageRectangle">gdImageRectangle</A>.
When gdAntiAliased is used as the color, the foreground color
set with <a href="#gdImageSetAntiAliased">gdImageSetAntiAliased</a>
is used, with antialiasing mechanisms to minimize any
"jagged" appearance. 
For more information, see
<a href="#gdImageSetAntiAliased">gdImageSetAntiAliased</a>.
<DT><A NAME="gdBrushed">gdBrushed</A> <strong>(CONSTANT)</strong>
<DD>
Used in place of a color when invoking a line-drawing
function such as <A HREF="#gdImageLine">gdImageLine</A>
or <A HREF="#gdImageRectangle">gdImageRectangle</A>.
When gdBrushed is used as the color, the brush
image set with <A HREF="#gdImageSetBrush">gdImageSetBrush</A>
is drawn in place of each pixel of the line (the brush is
usually larger than one pixel, creating the effect
of a wide paintbrush). See also
<A HREF="#gdStyledBrushed">gdStyledBrushed</A> for a way
to draw broken lines with a series of distinct copies of an image.
<DT><A NAME="gdMaxColors"><code>gdMaxColors</code><strong>(CONSTANT)</strong>
<DD>
The constant 256. This is the maximum number of colors in a palette-based
PNG file according to the PNG standard, and is also the maximum number of
colors in a palette-based gd image. This of course does not apply to
truecolor images.
<DT><A NAME="gdStyled">gdStyled</A> <strong>(CONSTANT)</strong>
<DD>
Used in place of a color when invoking a line-drawing
function such as <A HREF="#gdImageLine">gdImageLine</A>
or <A HREF="#gdImageRectangle">gdImageRectangle</A>.
When gdStyled is used as the color, the colors of the pixels are
drawn successively from the style that has been
set with <A HREF="#gdImageSetStyle">gdImageSetStyle</A>.
If the color of a pixel is equal to
<A HREF="#gdTransparent">gdTransparent</A>, that pixel
is not altered. (This mechanism is completely unrelated
to the "transparent color" of the image itself; see
<A HREF="#gdImageColorTransparent">gdImageColorTransparent</A>
gdImageColorTransparent for that mechanism.) See also
<A NAME="#gdStyledBrushed"> gdStyledBrushed</A>.
<DT><A NAME="gdStyledBrushed">gdStyledBrushed</A> <strong>(CONSTANT)</strong>
<DD>
Used in place of a color when invoking a line-drawing
function such as <A HREF="#gdImageLine">gdImageLine</A>
or <A HREF="#gdImageRectangle">gdImageRectangle</A>.
When gdStyledBrushed is used as the color, the brush
image set with <A HREF="#gdImageSetBrush">gdImageSetBrush</A>
is drawn at each pixel of the line, providing that the
style set with <A HREF="#gdImageSetStyle">gdImageSetStyle</A>
contains a nonzero value (OR gdTransparent, which
does not equal zero but is supported for consistency)
for the current pixel. (Pixels are drawn successively from the style as the
line is drawn, returning to the beginning when the
available pixels in the style are exhausted.) Note that
this differs from the behavior of <A HREF="#gdStyled">gdStyled</A>,
in which the values in the style are used as actual
pixel colors, except for gdTransparent.
<DT><A NAME="gdDashSize">gdDashSize</A> <strong>(CONSTANT)</strong>
<DD>
The length of a dash in a dashed line. Defined to be 4 for
backwards compatibility with programs that use
<A NAME="gdImageDashedLine">gdImageDashedLine</A>. New
programs should use <A NAME="gdImageSetStyle">
gdImageSetStyle</A> and call the standard
<A NAME="gdImageLine">gdImageLine</A> function
with the special "color" <A NAME="gdStyled">
gdStyled</A> or <A NAME="gdStyledBrushed">gdStyledBrushed</A>.
<DT><A NAME="gdTiled">gdTiled</A> <strong>(CONSTANT)</strong>
<DD>
Used in place of a normal color in <A HREF="#gdImageFilledRectangle">
gdImageFilledRectangle</A>, <A HREF="#gdImageFilledPolygon">
gdImageFilledPolygon</A>,
<A HREF="#gdImageFill">gdImageFill</A>, and <A HREF="#gdImageFillToBorder">
gdImageFillToBorder</A>. gdTiled selects a pixel from the
tile image set with <A HREF="#gdImageSetTile">gdImageSetTile</A>
in such a way as to ensure that the filled area will be
tiled with copies of the tile image. See the discussions of
<A HREF="#gdImageFill">gdImageFill</A> and
<A HREF="#gdImageFillToBorder">gdImageFillToBorder</A> for special
restrictions regarding those functions.
<DT><A NAME="gdTransparent">gdTransparent</A> <strong>(CONSTANT)</strong>
<DD>
Used in place of a normal color in a style to be set with
<A HREF="#gdImageSetStyle">gdImageSetStyle</A>.
gdTransparent is <strong>not</strong> the transparent
color index of the image; for that functionality please
see <A HREF="#gdImageColorTransparent">gdImageColorTransparent</A>.
</DL>

<A NAME="gdformat"><H3>About the additional .gd image file format</H3></A>
In addition to reading and writing the PNG and JPEG formats and reading the
X Bitmap format, gd has the capability to read and write its
own ".gd" format. This format is <em>not</em> intended for
general purpose use and should never be used to distribute
images. It is not a compressed format. Its purpose is solely to
allow very fast loading of images your program needs often in
order to build other images for output. If you are experiencing
performance problems when loading large, fixed PNG images your
program needs to produce its output images, you may wish
to examine the functions <A HREF="#gdImageCreateFromGd">
gdImageCreateFromGd</A> and <A HREF="#gdImageGd">gdImageGd</A>,
which read and write .gd format images.

<P>
The program "pngtogd.c" is provided as a simple way of converting
.png files to .gd format. I emphasize again that you will not
need to use this format unless you have a need for high-speed loading
of a few frequently-used images in your program.

<A NAME="gd2format"><H3>About the .gd2 image file format</H3></A>
In addition to reading and writing the PNG format and reading the
X Bitmap format, gd has the capability to read and write its
own ".gd2" format. This format is <em>not</em> intended for
general purpose use and should never be used to distribute
images. It is a compressed format allowing pseudo-random access
to large image files. Its purpose is solely to
allow very fast loading of <strong>parts</strong> of images
If you are experiencing
performance problems when loading large, fixed PNG or JPEG images your
program needs to produce its output images, you may wish
to examine the functions <A HREF="#gdImageCreateFromGd2">
gdImageCreateFromGd2</A>, <A HREF="#gdImageCreateFromGd2Part">
gdImageCreateFromGd2Part</A> and <A HREF="#gdImageGd2">gdImageGd2</A>,
which read and write .gd2 format images.

<P>
The program "pngtogd2.c" is provided as a simple way of converting
.png files to .gd2 format.

<A NAME="gdioctx"><H3>About the gdIOCtx structure</H3></A>
Version 1.5 of GD added a new style of I/O based on an IOCtx
structure (the most up-to-date version can be found in gd_io.h):
<PRE>
typedef struct gdIOCtx {
        int     (*getC)(struct gdIOCtx*);
        int     (*getBuf)(struct gdIOCtx*, void*, int);

        void     (*putC)(struct gdIOCtx*, int);
        int     (*putBuf)(struct gdIOCtx*, const void*, int);

        int     (*seek)(struct gdIOCtx*, const int); /* Returns 1 on SUCCESS */
        long    (*tell)(struct gdIOCtx*); 

        void    (*free)(struct gdIOCtx*);

} gdIOCtx;
</PRE>

Most functions that accepted files in previous versions now also have a
counterpart that accepts an I/O context. These functions have a 'Ctx'
suffix.
<p>
The <xxx>Ctx routines use the function pointers in the I/O context pointed to
by gdIOCtx to perform all I/O. Examples of how to implement an I/O context
can be found in io_file.c (which provides a wrapper for file routines), and
io_dp.c (which implements in-memory storage).
<p>
It is not necessary to implement all functions in an I/O context if you know
that it will only be used in limited cirsumstances. At the time of writing
(Version 1.6.1, July 1999), the known requirements are:
<p>
<Table>
<TR><TD>All</TD><td width=20>&nbsp;</td><TD>Must have 'free',</td></tr>
<TR><TD>Anything that reads from the context</TD><td></td><TD>Must have 'getC' and 'getBuf',</td></tr>
<TR><TD>Anything that writes to the context</TD><td></td><TD>Must have 'putC' and 'putBuf'.</td></tr>
<TR><TD>If gdCreateFromGd2Part is called</td><td></td><TD>Must also have 'seek' and 'tell'. Note: seek must return 1 on SUCCESS and 0 on FAILURE.</td></tr>
<TR><TD>If gdImageGd2 is called</td><td></td><TD>Must also have 'seek' and 'tell'.</td></tr>
</Table>



<A NAME="informing"><H3>Please tell us you're using gd!</H3>
When you contact us and let us know you are using gd,
you help us justify the time spent in maintaining and improving
it. So please let us know. If the results are publicly
visible on the web, a URL is a wonderful thing to receive, but
if it's not a publicly visible project, a simple note is just
as welcome.

<A NAME="support"><H3>How do I get support?</H3></A>
<h4>Free Support</h4>

Anyone can mail questions about the gd library to
<a target=_top href="http://www.boutell.com/contact">Thomas Boutell</a>. However, 
I receive a very large volume of email on
many subjects, and while I do my best to respond to all queries this can
take some time. Sometimes the response must take the form of an eventual
new release or an addition to a FAQ or other document, as opposed to an
detailed individual response.

<h4>Hourly Support</h4>
Those requiring support in detail may arrange for direct support
from the author, Thomas Boutell, at the rate of $50/hr, billed
directly by credit card. Purchase orders are also accepted from
Fortune 500 corporations and institutions in good standing.
To make arrangements, contact 
<a target=_top href="http://www.boutell.com/contact">Boutell.Com support</a>. To avoid delay
and/or confusion, be sure to specifically mention that you wish to
purchase gd support at the hourly rate above.

<H3><A NAME="index">Alphabetical quick index</A></H3>
<A HREF="#gdAntiAliased">gdAntiAliased</A> |
<A HREF="#gdBrushed">gdBrushed</A> |
<A HREF="#gdDashSize">gdDashSize</A> |
<A HREF="#gdFont">gdFont</A> |
<A HREF="#gdFontGetHuge">gdFontGetHuge</A> |
<A HREF="#gdFontGetLarge">gdFontGetLarge</A> |
<A HREF="#gdFontGetMediumBold">gdFontGetMediumBold</A> |
<A HREF="#gdFontGetSmall">gdFontGetSmall</A> |
<A HREF="#gdFontGetTiny">gdFontGetTiny</A> |
<A HREF="#gdFontCacheSetup">gdFontCacheSetup</A> |
<A HREF="#gdFontCacheShutdown">gdFontCacheShutdown</A> |
<A HREF="#gdFontPtr">gdFontPtr</A> |
<A HREF="#gdFree">gdFree</A> |
<A HREF="#gdImage">gdImage</A> |
<A HREF="#gdImageAlphaBlending">gdImageAlphaBlending</A> |
<A HREF="#gdImageArc">gdImageArc</A> |
<A HREF="#gdImageBlue">gdImageBlue</A> |
<A HREF="#gdImageBoundsSafe">gdImageBoundsSafe</A> |
<A HREF="#gdImageChar">gdImageChar</A> |
<A HREF="#gdImageCharUp">gdImageCharUp</A> |
<A HREF="#gdImageColorAllocate">gdImageColorAllocate</A> |
<A HREF="#gdImageColorAllocateAlpha">gdImageColorAllocateAlpha</A> |
<A HREF="#gdImageColorClosest">gdImageColorClosest</A> |
<A HREF="#gdImageColorClosestAlpha">gdImageColorClosestAlpha</A> |
<A HREF="#gdImageColorClosestHWB">gdImageColorClosestHWB</A> |
<A HREF="#gdImageColorDeallocate">gdImageColorDeallocate</A> |
<A HREF="#gdImageColorExact">gdImageColorExact</A> |
<A HREF="#gdImageColorExactAlpha">gdImageColorExactAlpha</A> |
<A HREF="#gdImageColorResolve">gdImageColorResolve</A> |
<A HREF="#gdImageColorResolveAlpha">gdImageColorResolveAlpha</A> |
<A HREF="#gdImageColorTransparent">gdImageColorTransparent</A> |
<A HREF="#gdImageCopy">gdImageCopy</A> |
<A HREF="#gdImageCopyMerge">gdImageCopyMerge</A> |
<A HREF="#gdImageCopyMergeGray">gdImageMergeGray</A> |
<A HREF="#gdImageCopyResized">gdImageCopyResized</A> |
<A HREF="#gdImageCopyResampled">gdImageCopyResampled</A> |
<A HREF="#gdImageCopyRotated">gdImageCopyRotated</A> |
<A HREF="#gdImageCreate">gdImageCreate</A> |
<A HREF="#gdImageCreate">gdImageCreatePalette</A> |
<A HREF="#gdImageCreate">gdImageCreateTrueColor</A> |
<A HREF="#gdImageCreateFromGd">gdImageCreateFromGd</A> |
<A HREF="#gdImageCreateFromGdCtx">gdImageCreateFromGdCtx</A> |
<A HREF="#gdImageCreateFromGdPtr">gdImageCreateFromGdPtr</A> |
<A HREF="#gdImageCreateFromGd2">gdImageCreateFromGd2</A> |
<A HREF="#gdImageCreateFromGd2Ctx">gdImageCreateFromGd2Ctx</A> |
<A HREF="#gdImageCreateFromGd2Ptr">gdImageCreateFromGd2Ptr</A> |
<A HREF="#gdImageCreateFromGd2Part">gdImageCreateFromGd2Part</A> |
<A HREF="#gdImageCreateFromGd2PartCtx">gdImageCreateFromGd2PartCtx</A> |
<A HREF="#gdImageCreateFromGd2PartPtr">gdImageCreateFromGd2PartPtr</A> |
<A HREF="#gdImageCreateFromJpeg">gdImageCreateFromJpeg</A> |
<A HREF="#gdImageCreateFromJpegCtx">gdImageCreateFromJpegCtx</A> |
<A HREF="#gdImageCreateFromJpegPtr">gdImageCreateFromJpegPtr</A> |
<A HREF="#gdImageCreateFromPng">gdImageCreateFromPng</A> |
<A HREF="#gdImageCreateFromPngCtx">gdImageCreateFromPngCtx</A> |
<A HREF="#gdImageCreateFromPngPtr">gdImageCreateFromPngPtr</A> |
<A HREF="#gdImageCreateFromPngSource">gdImageCreateFromPngSource</A> |
<A HREF="#gdImageCreateFromWBMP">gdImageCreateFromWBMP</A> |
<A HREF="#gdImageCreateFromWBMPCtx">gdImageCreateFromWBMPCtx</A> |
<A HREF="#gdImageCreateFromWBMPPtr">gdImageCreateFromWBMPPtr</A> |
<A HREF="#gdImageCreateFromXbm">gdImageCreateFromXbm</A> |
<A HREF="#gdImageCreateFromXpm">gdImageCreateFromXpm</A> |
<A HREF="#gdImageDashedLine">gdImageDashedLine</A> |
<A HREF="#gdImageDestroy">gdImageDestroy</A> |
<A HREF="#gdImageFill">gdImageFill</A> |
<A HREF="#gdImageFilledArc">gdImageFilledArc</A> |
<A HREF="#gdImageFilledEllipse">gdImageFilledEllipse</A> |
<A HREF="#gdImageFillToBorder">gdImageFillToBorder</A> |
<A HREF="#gdImageFilledRectangle">gdImageFilledRectangle</A> |
<A HREF="#gdImageGd">gdImageGd</A> |
<A HREF="#gdImageGd2">gdImageGd2</A> |
<A HREF="#gdImageGetInterlaced">gdImageGetInterlaced</A> |
<A HREF="#gdImageGetPixel">gdImageGetPixel</A> |
<A HREF="#gdImageGetTransparent">gdImageGetTransparent</A> |
<A HREF="#gdImageGifAnimAdd">gdImageGifAnimAdd</A> |
<A HREF="#gdImageGifAnimAddCtx">gdImageGifAnimAddCtx</A> |
<A HREF="#gdImageGifAnimAddPtr">gdImageGifAnimAddPtr</A> |
<A HREF="#gdImageGifAnimBegin">gdImageGifAnimBegin</A> |
<A HREF="#gdImageGifAnimBeginCtx">gdImageGifAnimBeginCtx</A> |
<A HREF="#gdImageGifAnimBeginPtr">gdImageGifAnimBeginPtr</A> |
<A HREF="#gdImageGifAnimEnd">gdImageGifAnimEnd</A> |
<A HREF="#gdImageGifAnimEndCtx">gdImageGifAnimEndCtx</A> |
<A HREF="#gdImageGifAnimEndPtr">gdImageGifAnimEndPtr</A> |
<A HREF="#gdImageGreen">gdImageGreen</A> |
<A HREF="#gdImageInterlace">gdImageInterlace</A> |
<A HREF="#gdImageJpeg">gdImageJpeg</A> |
<A HREF="#gdImageJpegCtx">gdImageJpegCtx</A> |
<A HREF="#gdImageLine">gdImageLine</A> |
<A HREF="#gdImageFilledPolygon">gdImageFilledPolygon</A> |
<A HREF="#gdImageOpenPolygon">gdImageOpenPolygon</A> |
<A HREF="#gdImagePaletteCopy">gdImagePaletteCopy</A> |
<A HREF="#gdImagePng">gdImagePng</A> |
<A HREF="#gdImagePngEx">gdImagePngEx</A> |
<A HREF="#gdImagePngCtx">gdImagePngCtx</A> |
<A HREF="#gdImagePngCtxEx">gdImagePngCtxEx</A> |
<A HREF="#gdImagePngPtr">gdImagePngPtr</A> |
<A HREF="#gdImagePngPtrEx">gdImagePngPtrEx</A> |
<A HREF="#gdImagePngToSink">gdImagePngToSink</A> |
<A HREF="#gdImagePolygon">gdImagePolygon</A> |
<A HREF="#gdImagePtr">gdImagePtr</A> |
<A HREF="#gdImageWBMP">gdImageWBMP</A> |
<A HREF="#gdImageWBMPCtx">gdImageWBMPCtx</A> |
<A HREF="#gdImageRectangle">gdImageRectangle</A> |
<A HREF="#gdImageRed">gdImageRed</A> |
<A HREF="#gdImageSaveAlpha">gdImageSaveAlpha</A> |
<A HREF="#gdImageSetAntiAliased">gdImageSetAntiAliased</A> |
<A HREF="#gdImageSetAntiAliasedDontBlend">gdImageSetAntiAliasedDontBlend</A> |
<A HREF="#gdImageSetBrush">gdImageSetBrush</A> |
<A HREF="#gdImageSetPixel">gdImageSetPixel</A> |
<A HREF="#gdImageSetStyle">gdImageSetStyle</A> |
<A HREF="#gdImageSetThickness">gdImageSetThickness</A> |
<A HREF="#gdImageSetTile">gdImageSetTile</A> |
<A HREF="#gdImageSharpen">gdImageSharpen</A> |
<A HREF="#gdImageSquareToCircle">gdImageSquareToCircle</A> |
<A HREF="#gdImageString">gdImageString</A> |
<A HREF="#gdImageString16">gdImageString16</A> |
<A HREF="#gdImageStringFT">gdImageStringFT</A> |
<A HREF="#gdImageStringFTCircle">gdImageStringFTCircle</A> |
<A HREF="#gdImageStringFTEx">gdImageStringFTEx</A> |
<A HREF="#gdImageStringTTF">gdImageStringTTF</A> |
<A HREF="#gdImageStringUp">gdImageStringUp</A> |
<A HREF="#gdImageStringUp">gdImageStringUp16</A> |
<A HREF="#gdImageToPalette">gdImageToPalette</A> |
<A HREF="#gdImageWBMP">gdImageWBMP</A> |
<A HREF="#gdMaxColors">gdMaxColors</A> |
<A HREF="#gdPoint">gdPoint</A> |
<A HREF="#gdStyled">gdStyled</A> |
<A HREF="#gdStyledBrushed">gdStyledBrushed</A> |
<A HREF="#gdTiled">gdTiled</A> |
<A HREF="#gdTransparent">gdTransparent</A>
<P>
<em><a target=_top HREF="http://www.boutell.com/">
Boutell.Com, Inc.</A></em>
</body>


</body>
<html>
